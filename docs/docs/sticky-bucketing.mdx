---
title: Sticky Bucketing
description: Ensure users see the same experiment variant, even when user session, user login status, or experiment parameters change
sidebar_label: Sticky Bucketing
slug: /app/sticky-bucketing
---

# Sticky Bucketing

This article serves two purposes:

- High level overview of GrowthBook's Sticky Bucketing feature
- Technical details on how to implement Sticky Bucketing in your codebase

Sticky bucketing ensures that users are consistently assigned the same experiment variant, even when user session, user login status, or experiment parameters change. GrowthBook's flavor of sticky bucketing has a few additional features:(1) Bucketing based on either a primary hash attribute (i.e. user id) or a secondary attribute (i.e. anonymous id) and (2) the ability to version-control and purge your users' assigned buckets.

## Motivation

So why would you want to use Sticky Bucketing? Let's look at a few examples:

1. You are measuring the impact on a metric with a long conversion window that crosses the log-in divide. The user may be first exposed to your experiment while anonymous, then sign up, log out, sign back in on another device, and then convert. Without sticky bucketing, there would be no way to tie the anonymous exposure to the conversion.

2. You are managing an experiment rollout and need to slow down enrollment. You decrease the percentage of traffic exposed to the experiment from 50% to 10% but you do not want to alter the experience for users who were already exposed to the experiment. Sticky bucketing allows you to apply the rollout percentage to new users while keeping the old users in their original buckets.

:::note
Sticky Bucketing is a GrowthBook Pro and Enterprise feature.
:::

## Setting up Sticky Bucketing

To use Sticky Bucketing for your experiments, there are a few steps that you need to complete.

### 1. Ensure you are using a compatible SDK version

Update your codebase to use a compatible SDK. Sticky Bucketing is currently supported in the following SDK versions:

- Javascript: `0.32.0`
- React: `0.22.0`

### 2. Update your SDK Connections in the GrowthBook app

Within the GrowthBook app, ensure that you have set your SDK Connection to use a compatible SDK version. You can do this by going to **SDK Connections** and ensuring each connection: (1) only corresponds to a single language and (2) has the correct SDK version specified. If you need to support multiple languages, create one SDK Connection for each language.

### 3. Enable Sticky Bucketing for your organization

In the GrowthBook app, go to **Settings** > **General** > **Experiment Settings** and enable the Sticky Bucketing toggle. This will add new options specific to Sticky Bucketing whenever you configure targeting (e.g choosing a `fallbackAttribute` for hashing) or make changes to your experiment (e.g. reduce traffic to an experiment).

For more information about experiment configuration using Sticky Bucketing, see [Experiments (setup)](/app/experiment-configuration).

### 4. Implement Sticky Bucketing in your codebase

You may use one of our built-in Sticky Bucketing Services or implement your own. We provide common drivers for browser-generated cookies, backend-generated cookies, browser LocalStorage, and Redis stores.

For more information about setting up Sticky Bucketing at the SDK level, see the appropriate SDK documentation. For instance, see the [Javascript SDK - Sticky Bucketing documentation](/lib/js/#sticky-bucketing) for more information about setting up Sticky Bucketing in the Javascript SDK.

## Example Implementations

### Front-end only

Suppose your website integrates GrowthBook on the front end only. You would like to implement Sticky Bucketing to protect against variation hopping should targeting or rollout rules change in the future.

In our JavaScript and React SDKs, we provide 2 different Sticky Bucket Services that make sense in this scenario: `LocalStorageStickyBucketService` and `BrowserCookieStickyBucketService`. You can instantiate either of these services and plug them into the GrowthBook SDK.

Additionally, depending on whether the benefits outweigh the risk of experimental bias for your experiment, you may like to implement Sticky Bucketing in a way that preserves user buckets across the logged-out / logged-in divide. This functionality can be achieved by choosing a fallback attribute in your experiment set up.

You may also have a standard `user_id` for logged-in users which is not present for anonymous users which in turn can be identified by `anonymous_id`. If you are not using a fallback attribute, then you would typically choose the `anonymous_id` as your hash attribute for your experiment and then ensure that this attribute is visible to the SDK. When configuring your experiment (either in the GrowthBook SDK or via inline experiment) you would likely want to set the `hashAttribute` to `anonymous_id`. When an anonymous user is bucketed, they will be assigned a bucket based on their `anonymous_id` and this bucket will be stored in a browser cookie or LocalStorage, and this bucket will be retained even when the experiment targeting or rollout rules change.

However if you do want to use a fallback attribute, you would want to ensure both `user_id` and `anonymous_id` attributes are visible to the SDK. When configuring your experiment you would want to set the `hashAttribute` to `user_id` and the `fallbackAttribute` to `anonymous_id`. Now when an anonymous user is bucketed, they will be assigned a bucket based on their `anonymous_id` and this bucket will be stored in a browser cookie or LocalStorage. Once they log in or register, a `user_id` should be made available to the SDK. As long as the `anonymous_id` is also available immediately after logging in, then the sticky bucket will be upgraded to remember both the `user_id` and `anonymous_id` going forward. If the user's session expires and they log back in later, they will retain the sticky bucket that was assigned to them previously.

### Front-end and Back-end

Let's expand the "front-end only" example above so that our back-end controllers also integrate with GrowthBook and can reference the same experiments. In this scenario, we would like both the front-end and back-end to perform bucketing and persist a sticky bucket that reliably crosses the front-end / back-end divide.

On the front end, you will want to use the `BrowserCookieStickyBucketService` because cookies are easily transportable to and from the back end. Then, assuming we are using an Express (NodeJS) server, we would use the `ExpressCookieStickyBucketService` on the back end. Importantly, if customizing the cookie name, you must ensure that the same name prefix is chosen for both the front-end and back-end cookies.

### Back-end only

Suppose that in a server-side context we are interested in persisting a user's bucket both across multiple requests and across other back-end (micro)services that may not have direct access to the incoming user request nor their cookies.

We could use a Redis instance inside our network and read/write to that for sticky bucket storage. In a NodeJS context, we could use the `RedisStickyBucketService` and pass in an `ioredis` client.

### Hybrid and custom implementations

You may wish to employ multiple strategies at once (front-end, back-end, Redis) or write your own sticky bucket connector for a SQL server or DynamoDB cluster. You could write your own custom sticky bucket connector by implementing the `StickyBucketService` interface. Within your connector, you could do things like:

- Connect to SQL server for sticky bucket reads/writes
- GET/POST/RPC to a custom bucketing microservice
- Wrap both the `ExpressCookieStickyBucketService` and `RedisStickyBucketService` within your custom service's getter and setter methods
- Trigger side effects on bucket reads/writes
