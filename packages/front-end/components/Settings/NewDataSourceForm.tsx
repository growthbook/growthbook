import {
  FC,
  useState,
  useEffect,
  ChangeEventHandler,
  ReactElement,
} from "react";
import {
  DataSourceInterfaceWithParams,
  DataSourceSettings,
} from "back-end/types/datasource";
import { useForm } from "react-hook-form";
import { MetricType } from "@back-end/types/metric";
import clsx from "clsx";
import { isDemoDatasourceProject } from "shared/demo-datasource";
import { useRouter } from "next/router";
import { useAuth } from "@/services/auth";
import track from "@/services/track";
import { getInitialSettings } from "@/services/datasources";
import {
  eventSchemas,
  dataSourceConnections,
  eventSchema,
} from "@/services/eventSchema";
import MultiSelectField from "@/components/Forms/MultiSelectField";
import { useDefinitions } from "@/services/DefinitionsContext";
import SelectField from "@/components/Forms/SelectField";
import Field from "@/components/Forms/Field";
import Modal from "@/components/Modal";
import { GBCircleArrowLeft } from "@/components/Icons";
import usePermissionsUtil from "@/hooks/usePermissionsUtils";
import EventSourceList from "./EventSourceList";
import ConnectionSettings from "./ConnectionSettings";
import styles from "./NewDataSourceForm.module.scss";

const NewDataSourceForm: FC<{
  data: Partial<DataSourceInterfaceWithParams>;
  existing: boolean;
  source: string;
  onCancel?: () => void;
  onSuccess: (id: string) => Promise<void>;
  showImportSampleData: boolean;
  inline?: boolean;
  secondaryCTA?: ReactElement;
}> = ({
  data,
  onSuccess,
  onCancel,
  source,
  existing,
  showImportSampleData,
  inline,
  secondaryCTA,
}) => {
  const {
    projects: allProjects,
    project,
    getDatasourceById,
    mutateDefinitions,
  } = useDefinitions();
  const [step, setStep] = useState(0);
  const [schema, setSchema] = useState("");
  const [dataSourceId, setDataSourceId] = useState<string | null>(
    data?.id || null
  );
  const [possibleTypes, setPossibleTypes] = useState(
    dataSourceConnections.map((d) => d.type)
  );

  const permissionsUtil = usePermissionsUtil();

  const [datasource, setDatasource] = useState<
    Partial<DataSourceInterfaceWithParams>
  >(data);
  const [lastError, setLastError] = useState("");
  const DEFAULT_DATA_SOURCE: Partial<DataSourceInterfaceWithParams> = {
    name: "My Datasource",
    settings: {},
  };

  const [
    datasourceSupportsAutoGeneratedMetrics,
    setDatasourceSupportsAutoGeneratedMetrics,
  ] = useState<boolean>(false);

  useEffect(() => {
    if (dataSourceId) {
      mutateDefinitions();
      const datasourceObj = getDatasourceById(dataSourceId);
      const supportsAutoGeneratedMetrics =
        datasourceObj?.properties?.supportsAutoGeneratedMetrics || false;
      setDatasourceSupportsAutoGeneratedMetrics(supportsAutoGeneratedMetrics);
    }
  }, [
    dataSourceId,
    datasource.properties?.supportsAutoGeneratedMetrics,
    datasourceSupportsAutoGeneratedMetrics,
    getDatasourceById,
    mutateDefinitions,
  ]);

  const form = useForm<{
    settings: DataSourceSettings | undefined;
    metricsToCreate: {
      name: string;
      sql: string;
      type: MetricType;
    }[];
  }>({
    defaultValues: {
      settings: data?.settings || DEFAULT_DATA_SOURCE.settings,
      metricsToCreate: [],
    },
  });
  const schemasMap = new Map();
  const dataSourcesMap = new Map();
  eventSchemas.forEach((o) => {
    schemasMap.set(o.value, o);
  });
  dataSourceConnections.forEach((d) => {
    dataSourcesMap.set(d.type, d);
  });
  const selectedSchema = schemasMap.get(schema) || {
    value: "custom",
    label: "Custom",
    intro:
      "To create a custom data source select the data warehouse where your events are stored and enter the necessary credentials to grant GrowthBook read-only access.",
  };
  useEffect(() => {
    track("View Datasource Form", {
      source,
      newDatasourceForm: true,
    });
  }, [source]);

  const { apiCall, orgId } = useAuth();

  const router = useRouter();

  // Filter out demo datasource from available projects
  const projects = allProjects.filter(
    (p) =>
      !isDemoDatasourceProject({
        projectId: p.id,
        organizationId: orgId || "",
      })
  );

  if (!datasource) {
    return null;
  }

  let ctaEnabled = true;
  let disabledMessage = null;

  if (!permissionsUtil.canViewCreateDataSourceModal(project)) {
    ctaEnabled = false;
    // @ts-expect-error TS(2322) If you come across this, please fix it!: Type '"You don't have permission to create data so... Remove this comment to see the full error message
    disabledMessage = "You don't have permission to create data sources.";
  }

  const saveDataConnection = async () => {
    setLastError("");

    try {
      if (!datasource.type) {
        throw new Error("Please select a data source type");
      }

      // Update
      if (dataSourceId) {
        const res = await apiCall<{ status: number; message: string }>(
          `/datasource/${dataSourceId}`,
          {
            method: "PUT",
            body: JSON.stringify(datasource),
          }
        );
        track("Updating Datasource Form", {
          source,
          type: datasource.type,
          schema: schema,
          newDatasourceForm: true,
        });
        if (res.status > 200) {
          throw new Error(res.message);
        }
      }
      // Create
      else {
        const updatedDatasource = {
          ...datasource,
          settings: {
            ...getInitialSettings(
              selectedSchema.value,
              // @ts-expect-error TS(2345) If you come across this, please fix it!: Argument of type 'PostgresConnectionParams | Athen... Remove this comment to see the full error message
              datasource.params,
              form.watch("settings.schemaOptions")
            ),
            ...(datasource.settings || {}),
          },
        };
        const res = await apiCall<{ id: string }>(`/datasources`, {
          method: "POST",
          body: JSON.stringify(updatedDatasource),
        });
        track("Submit Datasource Form", {
          source,
          type: datasource.type,
          schema,
          newDatasourceForm: true,
        });
        setDataSourceId(res.id);
        setDatasource(
          updatedDatasource as Partial<DataSourceInterfaceWithParams>
        );
        return res.id;
      }
    } catch (e) {
      track("Data Source Form Error", {
        source,
        type: datasource.type,
        error: e.message.substr(0, 32) + "...",
        newDatasourceForm: true,
      });
      setLastError(e.message);
      throw e;
    }
  };

  const updateSettings = async () => {
    const settings = getInitialSettings(
      selectedSchema.value,
      // @ts-expect-error TS(2345) If you come across this, please fix it!: Argument of type 'PostgresConnectionParams | Athen... Remove this comment to see the full error message
      datasource.params,
      form.watch("settings.schemaOptions")
    );
    if (!dataSourceId) {
      throw new Error("Could not find existing data source id");
    }

    const newVal = {
      ...datasource,
      settings: {
        ...settings,
        schemaOptions: form.watch("settings.schemaOptions"),
      },
      metricsToCreate: form.watch("metricsToCreate"),
    };
    setDatasource(newVal as Partial<DataSourceInterfaceWithParams>);
    await apiCall<{ status: number; message: string }>(
      `/datasource/${dataSourceId}`,
      {
        method: "PUT",
        body: JSON.stringify(newVal),
      }
    );
    track("Saving Datasource Query Settings", {
      source,
      type: datasource.type,
      schema: schema,
      newDatasourceForm: true,
    });
  };

  const onChange: ChangeEventHandler<HTMLInputElement | HTMLTextAreaElement> = (
    e
  ) => {
    setDatasource({
      ...datasource,
      [e.target.name]: e.target.value,
    });
  };
  const onManualChange = (name, value) => {
    setDatasource({
      ...datasource,
      [name]: value,
    });
  };

  const handleCustomSetup = () => {
    setSchema("custom");
    setDatasource({
      name: "My Datasource",
      settings: {},
      projects: project ? [project] : [],
    });
    // no options for custom:
    form.setValue(`settings.schemaOptions`, {});

    // set to all possible types:
    setPossibleTypes(dataSourceConnections.map((o) => o.type));
    // jump to next step
    setStep(2);
  };

  const setSchemaSettings = (s: eventSchema) => {
    setSchema(s.value);
    form.setValue("settings.schemaFormat", s.value);
    track("Selected Event Schema", {
      schema: s.value,
      source,
      newDatasourceForm: true,
    });
    // @ts-expect-error TS(2532) If you come across this, please fix it!: Object is possibly 'undefined'.
    if (s.types.length === 1) {
      // @ts-expect-error TS(2532) If you come across this, please fix it!: Object is possibly 'undefined'.
      const data = dataSourcesMap.get(s.types[0]);
      setDatasource({
        ...datasource,
        // @ts-expect-error TS(2532) If you come across this, please fix it!: Object is possibly 'undefined'.
        type: s.types[0],
        name: `${s.label}`,
        params: data.default,
      } as Partial<DataSourceInterfaceWithParams>);
    } else {
      setDatasource({
        name: `${s.label}`,
        settings: {},
        projects: project ? [project] : [],
      });
    }
    // @ts-expect-error TS(2345) If you come across this, please fix it!: Argument of type 'DataSourceType[] | undefined' is... Remove this comment to see the full error message
    setPossibleTypes(s.types);
    if (s.options) {
      s.options.map((o) => {
        form.setValue(`settings.schemaOptions.${o.name}`, o.defaultValue || "");
      });
    } else {
      form.setValue(`settings.schemaOptions`, {});
    }
  };

  const hasStep2 = !!selectedSchema?.options;
  const isFinalStep = step === 3 || (!hasStep2 && step === 2);
  const updateSettingsRequired = isFinalStep && dataSourceId && step !== 2;

  const submit =
    step === 0
      ? null
      : form.handleSubmit(async () => {
          let newDataId = dataSourceId;
          if (step === 2) {
            // @ts-expect-error TS(2322) If you come across this, please fix it!: Type 'string | undefined' is not assignable to typ... Remove this comment to see the full error message
            newDataId = await saveDataConnection();
          }
          if (updateSettingsRequired) {
            await updateSettings();
          }
          if (isFinalStep) {
            // @ts-expect-error TS(2345) If you come across this, please fix it!: Argument of type 'string | null' is not assignable... Remove this comment to see the full error message
            await onSuccess(newDataId);
            onCancel && onCancel();
          } else {
            setStep(step + 1);
          }
        });

  let stepContents: ReactElement;
  if (step === 0) {
    stepContents = (
      <div>
        <p>
          GrowthBook is warehouse native, which means we don&apos;t store a copy
          of your data and instead run <code>read-only</code> SELECT queries on
          your existing analytics infrastructure. These queries return the
          aggregated statistics necessary to analyze experiments, ensuring your
          data remains securely stored and unmodified.
        </p>
        <div>
          <h4>Choose Your Setup</h4>
          <div className="d-flex flex-wrap">
            <div
              className={clsx(
                styles.ctaContainer,
                !showImportSampleData && "w-50"
              )}
              onClick={() => setStep(1)}
            >
              <div className={styles.ctaButton}>
                <div>
                  <h3 className={styles.ctaText}>Guided Setup</h3>
                  <p>
                    Tell us what tool you use for event tracking in your app and
                    we&apos;ll guide you through the rest
                  </p>
                </div>
              </div>
            </div>
            <div
              className={clsx(
                styles.ctaContainer,
                !showImportSampleData && "w-50"
              )}
              onClick={(e) => {
                e.preventDefault();
                handleCustomSetup();
              }}
            >
              <div className={styles.ctaButton}>
                <div>
                  <h3 className={styles.ctaText}>Manual Setup</h3>
                  <p>
                    Connect to your data warehouse and manually configure
                    GrowthBook with SQL queries
                  </p>
                </div>
              </div>
            </div>
            {showImportSampleData && (
              <div
                className={styles.ctaContainer}
                onClick={(e) => {
                  e.preventDefault();
                  router.push("/demo-datasource-project");
                }}
              >
                <div className={styles.ctaButton}>
                  <h3 className={styles.ctaText}>Use Sample Dataset</h3>
                  <p className="mb-0 text-dark">
                    Explore GrowthBook with a pre-loaded sample dataset.
                  </p>
                </div>
              </div>
            )}
          </div>
        </div>
        {secondaryCTA && (
          <div className="col-12 text-center">{secondaryCTA}</div>
        )}
      </div>
    );
  } else if (step === 1) {
    stepContents = (
      <div>
        <div className="mb-3">
          <a
            href="#"
            onClick={(e) => {
              e.preventDefault();
              setLastError("");
              setStep(step - 1);
            }}
          >
            <span style={{ position: "relative", top: "-1px" }}>
              <GBCircleArrowLeft />
            </span>{" "}
            Back
          </a>
        </div>
        <h4>Select Your Event Tracker</h4>
        <p>
          GrowthBook has built-in support for a number of popular event tracking
          systems. Don&apos;t see yours listed? GrowthBook can work with
          virtually any type of data with a custom integration.
        </p>
        <EventSourceList
          onSelect={(s) => {
            if (s.value === "custom") {
              handleCustomSetup();
            } else {
              setSchemaSettings(s);
              // jump to next step
              setStep(2);
            }
          }}
        />
      </div>
    );
  } else if (step === 2) {
    stepContents = (
      <div>
        <div className="mb-3">
          <a
            href="#"
            onClick={(e) => {
              e.preventDefault();
              setLastError("");
              selectedSchema.value === "custom" ? setStep(0) : setStep(1);
            }}
          >
            <span style={{ position: "relative", top: "-1px" }}>
              <GBCircleArrowLeft />
            </span>{" "}
            Back
          </a>
        </div>
        <h3>{selectedSchema.label}</h3>
        {selectedSchema && selectedSchema.intro && (
          <div className="mb-4">{selectedSchema.intro}</div>
        )}
        <div className="form-group">
          <label>Name</label>
          <input
            type="text"
            className="form-control"
            name="name"
            required
            onChange={onChange}
            value={datasource.name}
          />
        </div>
        <SelectField
          label="Select the data warehouse where your event data is stored"
          // @ts-expect-error TS(2322) If you come across this, please fix it!: Type 'string | undefined' is not assignable to typ... Remove this comment to see the full error message
          value={datasource.type}
          onChange={(value) => {
            const option = dataSourceConnections.filter(
              (o) => o.type === value
            )[0];
            if (!option) return;

            setLastError("");

            track("Data Source Type Selected", {
              type: value,
              newDatasourceForm: true,
            });

            setDatasource({
              ...datasource,
              type: option.type,
              params: option.default,
            } as Partial<DataSourceInterfaceWithParams>);
          }}
          disabled={existing || possibleTypes.length === 1}
          required
          autoFocus={true}
          placeholder="Choose Type..."
          options={dataSourceConnections
            .filter((o) => {
              return !!possibleTypes.includes(o.type);
            })
            .map((o) => {
              return {
                value: o.type,
                label: o.display,
              };
            })}
        />
        <div className="form-group">
          <label>Description</label>
          <textarea
            className="form-control"
            name="description"
            onChange={onChange}
            value={datasource.description}
          />
        </div>
        {projects?.length > 0 && (
          <div className="form-group">
            <MultiSelectField
              label="Projects"
              placeholder="All projects"
              value={datasource.projects || []}
              options={projects.map((p) => ({ value: p.id, label: p.name }))}
              onChange={(v) => onManualChange("projects", v)}
              customClassName="label-overflow-ellipsis"
              helpText="Assign this data source to specific projects"
            />
          </div>
        )}
        <ConnectionSettings
          datasource={datasource}
          existing={existing}
          hasError={!!lastError}
          setDatasource={setDatasource}
        />
      </div>
    );
  } else {
    stepContents = (
      <div>
        <div className="mb-2">
          <a
            href="#"
            onClick={(e) => {
              e.preventDefault();
              setStep(2);
            }}
          >
            <span style={{ position: "relative", top: "-1px" }}>
              <GBCircleArrowLeft />
            </span>{" "}
            Back
          </a>
        </div>
        <div className="alert alert-success mb-3">
          <strong>Connection successful!</strong>
        </div>
        <h3>{schemasMap.get(schema)?.label || ""} Query Options</h3>
        <div className="my-4">
          <div className="d-inline-block">
            Below are are the typical defaults for{" "}
            {schemasMap.get(schema)?.label || "this data source"}.{" "}
            {selectedSchema?.options?.length === 1
              ? "The value "
              : "These values "}
            are used to generate the queries, which you can adjust as needed at
            any time.
          </div>
        </div>
        <div>
          {selectedSchema?.options?.map(({ name, label, type, helpText }) => (
            <div key={name} className="form-group">
              <Field
                label={label}
                name={name}
                value={form.watch(`settings.schemaOptions.${name}`)}
                type={type}
                onChange={(e) => {
                  form.setValue(
                    `settings.schemaOptions.${name}`,
                    e.target.value
                  );
                }}
                helpText={helpText}
              />
            </div>
          ))}
        </div>
      </div>
    );
  }

  // Disabling the CTA if the user hasn't input a data set to call attention to the "Test Connection" button
  if (
    step == 2 &&
    datasource.type === "bigquery" &&
    !datasource.params?.defaultDataset
  ) {
    ctaEnabled = false;
  }

  return (
    <Modal
      open={true}
      header={existing ? "Edit Data Source" : "Add Data Source"}
      close={onCancel}
      // @ts-expect-error TS(2322) If you come across this, please fix it!: Type 'null' is not assignable to type 'string | un... Remove this comment to see the full error message
      disabledMessage={disabledMessage}
      ctaEnabled={ctaEnabled}
      // @ts-expect-error TS(2322) If you come across this, please fix it!: Type '(() => Promise<void>) | null' is not assigna... Remove this comment to see the full error message
      submit={submit}
      autoCloseOnSubmit={false}
      cta={isFinalStep ? (step === 3 ? "Finish" : "Save") : "Next"}
      closeCta="Cancel"
      size="lg"
      error={lastError}
      inline={inline}
    >
      {stepContents}
    </Modal>
  );
};

export default NewDataSourceForm;
