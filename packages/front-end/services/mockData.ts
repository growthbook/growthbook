import {
  FactTableInterface,
  FactMetricInterface,
} from "shared/types/fact-table";
import type { RowFilter } from "shared/types/fact-table";
import {
  ExploreState,
  ExploreQueryResponse,
  ExploreLineChartSeries,
  ExploreBarChartSeries,
  ExploreDataPoint,
  ExploreSeries,
} from "shared/enterprise";

// ---------------------------------------------------------------------------
// Hardcoded mock data (generated by scripts/generate-mock-data-json.ts)
// Loaded synchronously when available; no random/generated fallback (empty data only).
// ---------------------------------------------------------------------------
export type FactTableRow = Record<string, unknown>;
export type HardcodedMockData = {
  factTables: Record<string, FactTableRow[]>;
  metrics: Record<string, ExploreDataPoint[]>;
};

let _hardcodedData: HardcodedMockData | null | undefined = undefined;

function getHardcodedData(): HardcodedMockData | null {
  if (_hardcodedData !== undefined) return _hardcodedData;
  try {
    const dummyFactTable =
      require("./mockData/factTables/dummy_fact_table.json") as FactTableRow[];
    const dummyPurchasesTable =
      require("./mockData/factTables/dummy_purchases_table.json") as FactTableRow[];
    const dummySessionsTable =
      require("./mockData/factTables/dummy_sessions_table.json") as FactTableRow[];
    const dummyFactMetric1 =
      require("./mockData/metrics/dummy_fact_metric_1.json") as ExploreDataPoint[];
    const dummyFactMetric2 =
      require("./mockData/metrics/dummy_fact_metric_2.json") as ExploreDataPoint[];
    _hardcodedData = {
      factTables: {
        dummy_fact_table: dummyFactTable,
        dummy_purchases_table: dummyPurchasesTable,
        dummy_sessions_table: dummySessionsTable,
      },
      metrics: {
        dummy_fact_metric_1: dummyFactMetric1,
        dummy_fact_metric_2: dummyFactMetric2,
      },
    };
    return _hardcodedData;
  } catch {
    _hardcodedData = null;
    return null;
  }
}

// Create dummy fact tables for testing/development
export function createDummyFactTables(): FactTableInterface[] {
  const now = new Date();

  return [
    {
      id: "dummy_fact_table",
      organization: "dummy_org",
      dateCreated: now,
      dateUpdated: now,
      name: "Dummy Events",
      description: "A dummy fact table for testing purposes",
      owner: "dummy_owner",
      projects: [],
      tags: [],
      datasource: "dummy_datasource",
      userIdTypes: ["user_id", "anonymous_id"],
      sql: `SELECT 
  timestamp,
  user_id,
  anonymous_id,
  event_name,
  properties
FROM events
WHERE timestamp BETWEEN '{{startDate}}' AND '{{endDate}}'`,
      eventName: "dummy_event",
      columns: [
        {
          dateCreated: now,
          dateUpdated: now,
          name: "Timestamp",
          description: "Event timestamp",
          column: "timestamp",
          datatype: "date",
          numberFormat: "",
          deleted: false,
        },
        {
          dateCreated: now,
          dateUpdated: now,
          name: "User ID",
          description: "User identifier",
          column: "user_id",
          datatype: "string",
          numberFormat: "",
          deleted: false,
        },
        {
          dateCreated: now,
          dateUpdated: now,
          name: "Anonymous ID",
          description: "Anonymous identifier",
          column: "anonymous_id",
          datatype: "string",
          numberFormat: "",
          deleted: false,
        },
        {
          dateCreated: now,
          dateUpdated: now,
          name: "Event Name",
          description: "Name of the event",
          column: "event_name",
          datatype: "string",
          numberFormat: "",
          deleted: false,
          alwaysInlineFilter: true,
        },
        {
          dateCreated: now,
          dateUpdated: now,
          name: "Properties",
          description: "Event properties",
          column: "properties",
          datatype: "json",
          numberFormat: "",
          deleted: false,
        },
      ],
      filters: [],
      archived: false,
    },
    {
      id: "dummy_purchases_table",
      organization: "dummy_org",
      dateCreated: now,
      dateUpdated: now,
      name: "Purchases",
      description: "E-commerce purchase transactions",
      owner: "dummy_owner",
      projects: [],
      tags: [],
      datasource: "dummy_datasource",
      userIdTypes: ["user_id", "customer_id"],
      sql: `SELECT 
  purchase_date as timestamp,
  user_id,
  customer_id,
  order_id,
  product_id,
  product_name,
  category,
  amount,
  quantity,
  currency,
  payment_method,
  shipping_country
FROM purchases
WHERE purchase_date BETWEEN '{{startDate}}' AND '{{endDate}}'
  AND status = 'completed'`,
      eventName: "purchase",
      columns: [
        {
          dateCreated: now,
          dateUpdated: now,
          name: "Timestamp",
          description: "Purchase timestamp",
          column: "timestamp",
          datatype: "date",
          numberFormat: "",
          deleted: false,
        },
        {
          dateCreated: now,
          dateUpdated: now,
          name: "User ID",
          description: "User identifier",
          column: "user_id",
          datatype: "string",
          numberFormat: "",
          deleted: false,
        },
        {
          dateCreated: now,
          dateUpdated: now,
          name: "Customer ID",
          description: "Customer identifier",
          column: "customer_id",
          datatype: "string",
          numberFormat: "",
          deleted: false,
        },
        {
          dateCreated: now,
          dateUpdated: now,
          name: "Order ID",
          description: "Order identifier",
          column: "order_id",
          datatype: "string",
          numberFormat: "",
          deleted: false,
        },
        {
          dateCreated: now,
          dateUpdated: now,
          name: "Product ID",
          description: "Product identifier",
          column: "product_id",
          datatype: "string",
          numberFormat: "",
          deleted: false,
        },
        {
          dateCreated: now,
          dateUpdated: now,
          name: "Product Name",
          description: "Name of the product",
          column: "product_name",
          datatype: "string",
          numberFormat: "",
          deleted: false,
        },
        {
          dateCreated: now,
          dateUpdated: now,
          name: "Category",
          description: "Product category",
          column: "category",
          datatype: "string",
          numberFormat: "",
          deleted: false,
          alwaysInlineFilter: true,
        },
        {
          dateCreated: now,
          dateUpdated: now,
          name: "Amount",
          description: "Purchase amount",
          column: "amount",
          datatype: "number",
          numberFormat: "currency",
          deleted: false,
        },
        {
          dateCreated: now,
          dateUpdated: now,
          name: "Quantity",
          description: "Quantity purchased",
          column: "quantity",
          datatype: "number",
          numberFormat: "",
          deleted: false,
        },
        {
          dateCreated: now,
          dateUpdated: now,
          name: "Currency",
          description: "Currency code",
          column: "currency",
          datatype: "string",
          numberFormat: "",
          deleted: false,
        },
        {
          dateCreated: now,
          dateUpdated: now,
          name: "Payment Method",
          description: "Payment method used",
          column: "payment_method",
          datatype: "string",
          numberFormat: "",
          deleted: false,
        },
        {
          dateCreated: now,
          dateUpdated: now,
          name: "Shipping Country",
          description: "Shipping country",
          column: "shipping_country",
          datatype: "string",
          numberFormat: "",
          deleted: false,
        },
      ],
      filters: [],
      archived: false,
    },
    {
      id: "dummy_sessions_table",
      organization: "dummy_org",
      dateCreated: now,
      dateUpdated: now,
      name: "User Sessions",
      description: "User session tracking data",
      owner: "dummy_owner",
      projects: [],
      tags: [],
      datasource: "dummy_datasource",
      userIdTypes: ["user_id", "session_id"],
      sql: `SELECT 
  session_start as timestamp,
  user_id,
  session_id,
  session_duration_seconds,
  page_views,
  events_count,
  referrer,
  utm_source,
  utm_medium,
  utm_campaign,
  device_type,
  browser,
  os,
  country
FROM user_sessions
WHERE session_start BETWEEN '{{startDate}}' AND '{{endDate}}'`,
      eventName: "session_start",
      columns: [
        {
          dateCreated: now,
          dateUpdated: now,
          name: "Timestamp",
          description: "Session start timestamp",
          column: "timestamp",
          datatype: "date",
          numberFormat: "",
          deleted: false,
        },
        {
          dateCreated: now,
          dateUpdated: now,
          name: "User ID",
          description: "User identifier",
          column: "user_id",
          datatype: "string",
          numberFormat: "",
          deleted: false,
        },
        {
          dateCreated: now,
          dateUpdated: now,
          name: "Session ID",
          description: "Session identifier",
          column: "session_id",
          datatype: "string",
          numberFormat: "",
          deleted: false,
        },
        {
          dateCreated: now,
          dateUpdated: now,
          name: "Session Duration",
          description: "Session duration in seconds",
          column: "session_duration_seconds",
          datatype: "number",
          numberFormat: "time:seconds",
          deleted: false,
        },
        {
          dateCreated: now,
          dateUpdated: now,
          name: "Page Views",
          description: "Number of page views in session",
          column: "page_views",
          datatype: "number",
          numberFormat: "",
          deleted: false,
        },
        {
          dateCreated: now,
          dateUpdated: now,
          name: "Events Count",
          description: "Total events in session",
          column: "events_count",
          datatype: "number",
          numberFormat: "",
          deleted: false,
        },
        {
          dateCreated: now,
          dateUpdated: now,
          name: "Referrer",
          description: "Referrer URL",
          column: "referrer",
          datatype: "string",
          numberFormat: "",
          deleted: false,
        },
        {
          dateCreated: now,
          dateUpdated: now,
          name: "UTM Source",
          description: "UTM source parameter",
          column: "utm_source",
          datatype: "string",
          numberFormat: "",
          deleted: false,
        },
        {
          dateCreated: now,
          dateUpdated: now,
          name: "UTM Medium",
          description: "UTM medium parameter",
          column: "utm_medium",
          datatype: "string",
          numberFormat: "",
          deleted: false,
        },
        {
          dateCreated: now,
          dateUpdated: now,
          name: "UTM Campaign",
          description: "UTM campaign parameter",
          column: "utm_campaign",
          datatype: "string",
          numberFormat: "",
          deleted: false,
        },
        {
          dateCreated: now,
          dateUpdated: now,
          name: "Device Type",
          description: "Device type (mobile, desktop, tablet)",
          column: "device_type",
          datatype: "string",
          numberFormat: "",
          deleted: false,
          alwaysInlineFilter: true,
        },
        {
          dateCreated: now,
          dateUpdated: now,
          name: "Browser",
          description: "Browser name",
          column: "browser",
          datatype: "string",
          numberFormat: "",
          deleted: false,
        },
        {
          dateCreated: now,
          dateUpdated: now,
          name: "OS",
          description: "Operating system",
          column: "os",
          datatype: "string",
          numberFormat: "",
          deleted: false,
        },
        {
          dateCreated: now,
          dateUpdated: now,
          name: "Country",
          description: "User country",
          column: "country",
          datatype: "string",
          numberFormat: "",
          deleted: false,
        },
      ],
      filters: [],
      archived: false,
    },
  ];
}

// Create dummy fact metrics for testing/development
export function createDummyFactMetrics(): FactMetricInterface[] {
  const now = new Date();
  const dummyFactTableId = "dummy_fact_table";

  return [
    {
      id: "dummy_fact_metric_1",
      organization: "dummy_org",
      dateCreated: now,
      dateUpdated: now,
      name: "Page Views",
      description: "A dummy metric for page views",
      owner: "dummy_owner",
      projects: [],
      tags: [],
      datasource: "dummy_datasource",
      metricType: "mean",
      numerator: {
        factTableId: dummyFactTableId,
        column: "$$count",
        rowFilters: [
          {
            column: "event_name",
            operator: "=",
            values: ["Page View"],
          },
        ],
      },
      denominator: null,
      inverse: false,
      cappingSettings: {
        type: "",
        value: 1000,
        ignoreZeros: false,
      },
      windowSettings: {
        type: "",
        delayValue: 1,
        delayUnit: "days",
        windowValue: 1,
        windowUnit: "days",
      },
      priorSettings: {
        override: false,
        proper: false,
        mean: 0,
        stddev: 1,
      },
      quantileSettings: null,
      maxPercentChange: 100,
      minPercentChange: 0.1,
      minSampleSize: 100,
      targetMDE: 0.1,
      displayAsPercentage: false,
      winRisk: 0.1,
      loseRisk: 0.05,
      regressionAdjustmentOverride: true,
      regressionAdjustmentEnabled: false,
      regressionAdjustmentDays: 10,
      archived: false,
    },
    {
      id: "dummy_fact_metric_2",
      organization: "dummy_org",
      dateCreated: now,
      dateUpdated: now,
      name: "Conversion Rate",
      description: "A dummy ratio metric for conversion rate",
      owner: "dummy_owner",
      projects: [],
      tags: [],
      datasource: "dummy_datasource",
      metricType: "ratio",
      numerator: {
        factTableId: dummyFactTableId,
        column: "$$count",
        rowFilters: [
          {
            column: "event_name",
            operator: "=",
            values: ["Purchase"],
          },
        ],
      },
      denominator: {
        factTableId: dummyFactTableId,
        column: "$$count",
        rowFilters: [
          {
            column: "event_name",
            operator: "=",
            values: ["Page View"],
          },
        ],
      },
      inverse: false,
      cappingSettings: {
        type: "",
        value: 1000,
        ignoreZeros: false,
      },
      windowSettings: {
        type: "",
        delayValue: 1,
        delayUnit: "days",
        windowValue: 1,
        windowUnit: "days",
      },
      priorSettings: {
        override: false,
        proper: false,
        mean: 0,
        stddev: 1,
      },
      quantileSettings: null,
      maxPercentChange: 100,
      minPercentChange: 0.1,
      minSampleSize: 100,
      targetMDE: 0.1,
      displayAsPercentage: true,
      winRisk: 0.1,
      loseRisk: 0.05,
      regressionAdjustmentOverride: true,
      regressionAdjustmentEnabled: false,
      regressionAdjustmentDays: 10,
      archived: false,
    },
  ];
}

// ---------------------------------------------------------------------------
// Helpers for hardcoded data: date extraction, filtering, aggregation
// ---------------------------------------------------------------------------
function getDateFromRow(row: FactTableRow, dateColumn: string): string {
  const v = row[dateColumn];
  if (v == null) return "";
  if (typeof v === "string") {
    return v.slice(0, 10);
  }
  if (typeof v === "number") return new Date(v).toISOString().slice(0, 10);
  return "";
}

function getDateBucket(dateStr: string, granularity: string): string {
  if (!dateStr || dateStr.length < 10) return dateStr;
  const d = new Date(dateStr + "T00:00:00Z");
  if (granularity === "day") return dateStr;
  if (granularity === "week") {
    const day = d.getUTCDay();
    const monday = new Date(d);
    monday.setUTCDate(d.getUTCDate() - (day === 0 ? 6 : day - 1));
    return monday.toISOString().slice(0, 10);
  }
  if (granularity === "month") return dateStr.slice(0, 7);
  if (granularity === "year") return dateStr.slice(0, 4);
  return dateStr;
}

function rowMatchesFilter(row: FactTableRow, filter: RowFilter): boolean {
  const col = filter.column;
  const val = col != null ? row[col] : undefined;
  const strVal = val == null ? "" : String(val);
  const numVal = typeof val === "number" ? val : Number(val);
  const values = filter.values ?? [];
  const op = filter.operator;

  switch (op) {
    case "=":
      return values.length > 0 && values.some((v) => strVal === v);
    case "!=":
      return values.length === 0 || !values.some((v) => strVal === v);
    case "in":
      return values.some((v) => strVal === v);
    case "not_in":
      return !values.some((v) => strVal === v);
    case "contains":
      return values.some((v) => strVal.includes(v));
    case "not_contains":
      return values.length === 0 || !values.some((v) => strVal.includes(v));
    case "starts_with":
      return values.some((v) => strVal.startsWith(v));
    case "ends_with":
      return values.some((v) => strVal.endsWith(v));
    case "<":
      return (
        values.length > 0 && !Number.isNaN(numVal) && numVal < Number(values[0])
      );
    case "<=":
      return (
        values.length > 0 &&
        !Number.isNaN(numVal) &&
        numVal <= Number(values[0])
      );
    case ">":
      return (
        values.length > 0 && !Number.isNaN(numVal) && numVal > Number(values[0])
      );
    case ">=":
      return (
        values.length > 0 &&
        !Number.isNaN(numVal) &&
        numVal >= Number(values[0])
      );
    case "is_null":
      return val == null || strVal === "";
    case "not_null":
      return val != null && strVal !== "";
    case "is_true":
      return val === true || strVal.toLowerCase() === "true";
    case "is_false":
      return val === false || strVal.toLowerCase() === "false";
    default:
      return true;
  }
}

function filterRows(
  rows: FactTableRow[],
  dateColumn: string,
  startDateStr: string,
  endDateStr: string,
  globalFilters: RowFilter[] | undefined,
  seriesFilters: RowFilter[] | undefined,
): FactTableRow[] {
  return rows.filter((row) => {
    const dateStr = getDateFromRow(row, dateColumn);
    if (dateStr < startDateStr || dateStr > endDateStr) return false;
    for (const f of globalFilters ?? []) {
      if (!rowMatchesFilter(row, f)) return false;
    }
    for (const f of seriesFilters ?? []) {
      if (!rowMatchesFilter(row, f)) return false;
    }
    return true;
  });
}

function getDateColumnForFactTable(factTableId: string): string {
  const tables = createDummyFactTables();
  const t = tables.find((x) => x.id === factTableId);
  const dateCol = t?.columns.find((c) => c.datatype === "date");
  return dateCol?.column ?? "timestamp";
}

type AggregatedBucket = { value: number; units: number };
type TimeSeriesBucket = { bucket: string; value: number; units: number };

function aggregateFactTableRows(
  rows: FactTableRow[],
  dateColumn: string,
  valueType: "count" | "unit_count" | "sum",
  unitColumn: string | undefined,
  valueColumn: string | undefined,
  groupByColumn: string | undefined,
  granularity: string,
  asTimeSeries: boolean,
): TimeSeriesBucket[] | Record<string, AggregatedBucket> {
  const unitCol = unitColumn ?? "user_id";

  if (asTimeSeries) {
    const byBucket = new Map<
      string,
      { value: number; units: Set<string> | number; sum?: number }
    >();
    for (const row of rows) {
      const dateStr = getDateFromRow(row, dateColumn);
      const bucket = getDateBucket(dateStr, granularity);
      if (!bucket) continue;
      let entry = byBucket.get(bucket);
      if (!entry) {
        entry =
          valueType === "unit_count"
            ? { value: 0, units: new Set<string>() }
            : valueType === "count"
              ? { value: 0, units: 0 }
              : { value: 0, units: 0, sum: 0 };
        byBucket.set(bucket, entry);
      }
      if (valueType === "unit_count") {
        const u = String(row[unitCol] ?? "");
        (entry.units as Set<string>).add(u);
        entry.value = (entry.units as Set<string>).size;
      } else if (valueType === "count") {
        entry.value += 1;
        (entry as { units: number }).units += 1;
      } else {
        const v = Number(row[valueColumn ?? ""] ?? 0);
        entry.value += v;
        (entry as { sum: number }).sum =
          ((entry as { sum?: number }).sum ?? 0) + v;
        (entry as { units: number }).units =
          ((entry as { units: number }).units ?? 0) + 1;
      }
    }
    const sortedBuckets = Array.from(byBucket.keys()).sort();
    const result: TimeSeriesBucket[] = [];
    for (const bucket of sortedBuckets) {
      const e = byBucket.get(bucket)!;
      let value = e.value;
      let units: number;
      if (valueType === "unit_count") {
        units = (e.units as Set<string>).size;
        value = units;
      } else if (valueType === "sum") {
        units = (e as { units: number }).units;
        value = (e as { sum: number }).sum ?? 0;
      } else {
        units = (e.units as number) ?? value;
      }
      result.push({ bucket, value, units });
    }
    return result;
  }

  const byGroup = new Map<
    string,
    { value: number; units: Set<string> | number; sum?: number }
  >();
  const groupCol = groupByColumn ?? "";
  for (const row of rows) {
    const group = groupCol ? String(row[groupCol] ?? "") : "_total";
    let entry = byGroup.get(group);
    if (!entry) {
      entry =
        valueType === "unit_count"
          ? { value: 0, units: new Set<string>() }
          : valueType === "count"
            ? { value: 0, units: 0 }
            : { value: 0, units: 0, sum: 0 };
      byGroup.set(group, entry);
    }
    if (valueType === "unit_count") {
      const u = String(row[unitCol] ?? "");
      (entry.units as Set<string>).add(u);
      entry.value = (entry.units as Set<string>).size;
    } else if (valueType === "count") {
      entry.value += 1;
      (entry as { units: number }).units += 1;
    } else {
      const v = Number(row[valueColumn ?? ""] ?? 0);
      entry.value += v;
      (entry as { sum: number }).sum =
        ((entry as { sum?: number }).sum ?? 0) + v;
      (entry as { units: number }).units =
        ((entry as { units: number }).units ?? 0) + 1;
    }
  }
  const out: Record<string, AggregatedBucket> = {};
  for (const [group, e] of byGroup) {
    let value = e.value;
    let units: number;
    if (valueType === "unit_count") {
      units = (e.units as Set<string>).size;
      value = units;
    } else if (valueType === "sum") {
      units = (e as { units: number }).units;
      value = (e as { sum: number }).sum ?? 0;
    } else {
      units = (e.units as number) ?? value;
    }
    out[group] = { value, units };
  }
  return out;
}

function aggregateMetricRows(
  points: ExploreDataPoint[],
  startDateStr: string,
  endDateStr: string,
  granularity: string,
  asSingleTotal: boolean,
): ExploreDataPoint[] | ExploreDataPoint {
  const filtered = points.filter(
    (p) => p.date >= startDateStr && p.date <= endDateStr,
  );
  if (asSingleTotal) {
    let numerator = 0;
    let denominator = 0;
    let units = 0;
    for (const p of filtered) {
      numerator += p.numerator ?? p.mean * (p.units || 1);
      denominator += p.denominator ?? 0;
      units += p.units ?? 0;
    }
    const value = numerator;
    const mean = units > 0 ? value / units : 0;
    return {
      date: startDateStr,
      units,
      mean,
      stddev: mean * 0.1,
      numerator: value,
      ...(denominator ? { denominator } : {}),
    };
  }
  const byBucket = new Map<
    string,
    { numerator: number; denominator: number; units: number; count: number }
  >();
  for (const p of filtered) {
    const bucket = getDateBucket(p.date, granularity);
    let entry = byBucket.get(bucket);
    if (!entry) {
      entry = { numerator: 0, denominator: 0, units: 0, count: 0 };
      byBucket.set(bucket, entry);
    }
    entry.numerator += p.numerator ?? p.mean * (p.units || 1);
    entry.denominator += p.denominator ?? 0;
    entry.units += p.units ?? 0;
    entry.count += 1;
  }
  const result: ExploreDataPoint[] = [];
  const sorted = Array.from(byBucket.keys()).sort();
  for (const bucket of sorted) {
    const e = byBucket.get(bucket)!;
    const value = e.numerator;
    const mean = e.denominator
      ? value / e.denominator
      : e.units
        ? value / e.units
        : 0;
    result.push({
      date: bucket,
      units: e.units,
      mean,
      stddev: mean * 0.1,
      numerator: value,
      ...(e.denominator ? { denominator: e.denominator } : {}),
    });
  }
  return result;
}

/**
 * Generates mock explore data based on the explore state
 * This emulates the API response from the backend
 */
export function generateMockExploreData(
  exploreState: ExploreState,
): ExploreQueryResponse {
  const { visualizationType, series, lookbackDays, granularity, groupBy } =
    exploreState;

  // Calculate date range
  const endDate = new Date();
  const startDate = new Date();
  startDate.setDate(startDate.getDate() - lookbackDays);
  const startDateStr = startDate.toISOString().split("T")[0];
  const endDateStr = endDate.toISOString().split("T")[0];

  const data = getHardcodedData();
  const useHardcoded = data != null && series.length > 0;

  // Hardcoded JSON may use 2024 or 2025; clamp range so we always return data
  const HARDCODED_DATA_START = "2024-01-01";
  const HARDCODED_DATA_END = "2025-12-31";
  let effectiveStartStr = startDateStr;
  let effectiveEndStr = endDateStr;
  if (useHardcoded) {
    if (effectiveStartStr < HARDCODED_DATA_START)
      effectiveStartStr = HARDCODED_DATA_START;
    if (effectiveEndStr > HARDCODED_DATA_END)
      effectiveEndStr = HARDCODED_DATA_END;
    if (effectiveStartStr > effectiveEndStr) {
      effectiveStartStr = HARDCODED_DATA_START;
      effectiveEndStr = HARDCODED_DATA_END;
    }
    if (
      typeof process !== "undefined" &&
      process.env?.NODE_ENV === "development"
    ) {
      // eslint-disable-next-line no-console
      console.log("[mockData] generateMockExploreData", {
        useHardcoded,
        visualizationType,
        groupBy,
        requestedRange: { startDateStr, endDateStr },
        effectiveRange: { effectiveStartStr, effectiveEndStr },
      });
    }
  }

  if (useHardcoded) {
    const gran = granularity ?? "day";
    const getSeriesTitle = (s: ExploreSeries): string => {
      if (s.name) return s.name;
      if (s.type === "metric") {
        const config = s.config as { factMetricId: string };
        const metric = createDummyFactMetrics().find(
          (m) => m.id === config.factMetricId,
        );
        return metric?.name ?? config.factMetricId;
      }
      if (s.type === "factTable") {
        const config = s.config as { factTableId: string };
        const table = createDummyFactTables().find(
          (t) => t.id === config.factTableId,
        );
        return table?.name ?? config.factTableId;
      }
      return s.id;
    };

    if (visualizationType === "bigNumber") {
      const firstSeries = series[0];
      if (!firstSeries) {
        return {
          type: "bigNumber",
          data: { value: 0, units: 0, mean: 0 },
        };
      }
      if (
        firstSeries.type === "metric" &&
        "factMetricId" in firstSeries.config
      ) {
        const metricRows = data.metrics[firstSeries.config.factMetricId];
        if (metricRows) {
          const single = aggregateMetricRows(
            metricRows,
            effectiveStartStr,
            effectiveEndStr,
            gran,
            true,
          ) as ExploreDataPoint;
          return {
            type: "bigNumber",
            data: {
              value: single.numerator ?? single.mean * single.units,
              units: single.units,
              mean: single.mean,
              stddev: single.stddev,
              numerator: single.numerator,
              denominator: single.denominator,
            },
          };
        }
      }
      if (
        firstSeries.type === "factTable" &&
        "factTableId" in firstSeries.config
      ) {
        const tableId = firstSeries.config.factTableId;
        const rows = data.factTables[tableId];
        if (rows) {
          const dateCol = getDateColumnForFactTable(tableId);
          const valueType = firstSeries.config.valueType ?? "count";
          const filtered = filterRows(
            rows,
            dateCol,
            effectiveStartStr,
            effectiveEndStr,
            exploreState.globalRowFilters,
            firstSeries.rowFilters,
          );
          const agg = aggregateFactTableRows(
            filtered,
            dateCol,
            valueType,
            firstSeries.config.unit,
            firstSeries.config.valueColumn,
            undefined,
            gran,
            false,
          ) as Record<string, AggregatedBucket>;
          const total = agg["_total"] ?? Object.values(agg)[0];
          const value = total?.value ?? 0;
          const units = total?.units ?? 0;
          return {
            type: "bigNumber",
            data: {
              value,
              units,
              mean: units ? value / units : 0,
              stddev: 0,
              numerator: value,
            },
          };
        }
      }
    }

    if (visualizationType === "bar") {
      const groupByCol = groupBy?.[0];
      const barSeries: ExploreBarChartSeries[] = series.map((seriesItem) => {
        if (
          seriesItem.type === "metric" &&
          "factMetricId" in seriesItem.config
        ) {
          const metricRows = data.metrics[seriesItem.config.factMetricId];
          if (!metricRows) {
            return {
              id: seriesItem.id,
              title: getSeriesTitle(seriesItem),
              groups: [],
            };
          }
          const filtered = metricRows.filter(
            (p) => p.date >= effectiveStartStr && p.date <= effectiveEndStr,
          );
          const byGroup = new Map<
            string,
            { numerator: number; denominator: number; units: number }
          >();
          for (const p of filtered) {
            const group = "_total";
            let e = byGroup.get(group);
            if (!e) {
              e = { numerator: 0, denominator: 0, units: 0 };
              byGroup.set(group, e);
            }
            e.numerator += p.numerator ?? p.mean * (p.units || 1);
            e.denominator += p.denominator ?? 0;
            e.units += p.units ?? 0;
          }
          const groups = Array.from(byGroup.entries()).map(([group, e]) => ({
            group,
            amount: e.numerator,
            units: e.units,
            mean: e.denominator
              ? e.numerator / e.denominator
              : e.units
                ? e.numerator / e.units
                : 0,
            stddev: 0,
            numerator: e.numerator,
            denominator: e.denominator || undefined,
          }));
          return {
            id: seriesItem.id,
            title: getSeriesTitle(seriesItem),
            groups,
          };
        }
        if (
          seriesItem.type === "factTable" &&
          "factTableId" in seriesItem.config
        ) {
          const tableId = seriesItem.config.factTableId;
          const rows = data.factTables[tableId];
          if (!rows) {
            return {
              id: seriesItem.id,
              title: getSeriesTitle(seriesItem),
              groups: [],
            };
          }
          const dateCol = getDateColumnForFactTable(tableId);
          const valueType = seriesItem.config.valueType ?? "count";
          const filtered = filterRows(
            rows,
            dateCol,
            effectiveStartStr,
            effectiveEndStr,
            exploreState.globalRowFilters,
            seriesItem.rowFilters,
          );
          const agg = aggregateFactTableRows(
            filtered,
            dateCol,
            valueType,
            seriesItem.config.unit,
            seriesItem.config.valueColumn,
            groupByCol,
            gran,
            false,
          ) as Record<string, AggregatedBucket>;
          const groups = Object.entries(agg)
            .filter(([k]) => k !== "_total" || !groupByCol)
            .map(([group, b]) => ({
              group,
              amount: b.value,
              units: b.units,
              mean: b.units ? b.value / b.units : 0,
              stddev: 0,
              numerator: b.value,
            }));
          return {
            id: seriesItem.id,
            title: getSeriesTitle(seriesItem),
            groups,
          };
        }
        return {
          id: seriesItem.id,
          title: getSeriesTitle(seriesItem),
          groups: [],
        };
      });
      return { type: "bar", series: barSeries };
    }

    if (visualizationType === "timeseries" || !visualizationType) {
      const lineSeries: ExploreLineChartSeries[] = series.map((seriesItem) => {
        if (
          seriesItem.type === "metric" &&
          "factMetricId" in seriesItem.config
        ) {
          const metricRows = data.metrics[seriesItem.config.factMetricId];
          if (!metricRows) {
            return {
              id: seriesItem.id,
              title: getSeriesTitle(seriesItem),
              data: [],
            };
          }
          const points = aggregateMetricRows(
            metricRows,
            startDateStr,
            endDateStr,
            gran,
            false,
          ) as ExploreDataPoint[];
          return {
            id: seriesItem.id,
            title: getSeriesTitle(seriesItem),
            data: points,
          };
        }
        if (
          seriesItem.type === "factTable" &&
          "factTableId" in seriesItem.config
        ) {
          const tableId = seriesItem.config.factTableId;
          const rows = data.factTables[tableId];
          if (!rows) {
            return {
              id: seriesItem.id,
              title: getSeriesTitle(seriesItem),
              data: [],
            };
          }
          const dateCol = getDateColumnForFactTable(tableId);
          const valueType = seriesItem.config.valueType ?? "count";
          const filtered = filterRows(
            rows,
            dateCol,
            startDateStr,
            endDateStr,
            exploreState.globalRowFilters,
            seriesItem.rowFilters,
          );
          const agg = aggregateFactTableRows(
            filtered,
            dateCol,
            valueType,
            seriesItem.config.unit,
            seriesItem.config.valueColumn,
            undefined,
            gran,
            true,
          ) as TimeSeriesBucket[];
          const dataPoints: ExploreDataPoint[] = agg.map((b) => ({
            date: b.bucket,
            units: b.units,
            mean: b.units ? b.value / b.units : 0,
            stddev: 0,
            numerator: b.value,
          }));
          return {
            id: seriesItem.id,
            title: getSeriesTitle(seriesItem),
            data: dataPoints,
          };
        }
        return {
          id: seriesItem.id,
          title: getSeriesTitle(seriesItem),
          data: [],
        };
      });
      return { type: "linechart", series: lineSeries };
    }
  }

  // No hardcoded data: return empty/default responses (generated random data disabled)
  const getSeriesTitle = (s: ExploreSeries): string => {
    if (s.name) return s.name;
    if (s.type === "metric" && "factMetricId" in s.config)
      return `Metric ${s.config.factMetricId}`;
    if (s.type === "factTable" && "factTableId" in s.config)
      return `Fact Table ${s.config.factTableId}`;
    return `Series ${s.id}`;
  };

  if (visualizationType === "bigNumber") {
    return { type: "bigNumber", data: { value: 0, units: 0, mean: 0 } };
  }
  if (visualizationType === "bar") {
    const barSeries: ExploreBarChartSeries[] = series.map((s) => ({
      id: s.id,
      title: getSeriesTitle(s),
      groups: [],
    }));
    return { type: "bar", series: barSeries };
  }
  const lineSeries: ExploreLineChartSeries[] = series.map((s) => ({
    id: s.id,
    title: getSeriesTitle(s),
    data: [],
  }));
  return { type: "linechart", series: lineSeries };
}

/* ---------------------------------------------------------------------------
 * GENERATED MOCK DATA - COMMENTED OUT (use only hardcoded data from mockData/*.json)
 * ---------------------------------------------------------------------------
 * Helper function to generate realistic group names based on column type and fact table metadata
 *
function generateGroupNames(
  column: string,
  factTableId: string | null,
  count?: number
): string[] {
  const factTables = createDummyFactTables();
  const factTable = factTableId
    ? factTables.find((ft) => ft.id === factTableId)
    : null;
  const columnDef = factTable?.columns.find(
    (col) => col.column === column || col.name.toLowerCase().includes(column.toLowerCase())
  );
  const groupCount = count ?? Math.floor(3 + Math.random() * 6);
  const columnLower = column.toLowerCase();
  const columnName = columnDef?.name.toLowerCase() || columnLower;
  if (columnLower.includes("device") || columnName.includes("device")) {
    const devices = ["Mobile", "Desktop", "Tablet", "Smart TV", "Wearable"];
    return devices.slice(0, Math.min(groupCount, devices.length));
  }
  if (columnLower.includes("browser") || columnName.includes("browser")) {
    const browsers = ["Chrome", "Firefox", "Safari", "Edge", "Opera", "Brave", "Samsung Internet"];
    return browsers.slice(0, Math.min(groupCount, browsers.length));
  }
  if (columnLower.includes("os") || columnName.includes("operating system") ||
      (columnLower === "os" && !columnLower.includes("browser"))) {
    const oses = ["Windows", "macOS", "Linux", "iOS", "Android", "Chrome OS"];
    return oses.slice(0, Math.min(groupCount, oses.length));
  }
  if (columnLower.includes("country") || columnName.includes("country")) {
    const countries = [
      "United States", "United Kingdom", "Canada", "Germany", "France",
      "Australia", "Japan", "Brazil", "India", "Spain", "Italy", "Netherlands"
    ];
    return countries.slice(0, Math.min(groupCount, countries.length));
  }
  if (columnLower.includes("payment") || columnName.includes("payment")) {
    const methods = [
      "Credit Card", "Debit Card", "PayPal", "Apple Pay", "Google Pay",
      "Bank Transfer", "Cryptocurrency", "Cash on Delivery"
    ];
    return methods.slice(0, Math.min(groupCount, methods.length));
  }
  if (columnLower.includes("category") || columnName.includes("category")) {
    const categories = [
      "Electronics", "Clothing", "Food & Beverage", "Books", "Toys",
      "Home & Garden", "Sports", "Beauty", "Automotive", "Health"
    ];
    return categories.slice(0, Math.min(groupCount, categories.length));
  }
  if (columnLower.includes("utm_source") || columnName.includes("utm source")) {
    const sources = ["Google", "Facebook", "Twitter", "LinkedIn", "Email", "Direct", "Organic"];
    return sources.slice(0, Math.min(groupCount, sources.length));
  }
  if (columnLower.includes("utm_medium") || columnName.includes("utm medium")) {
    const mediums = ["cpc", "social", "email", "organic", "referral", "display", "affiliate"];
    return mediums.slice(0, Math.min(groupCount, mediums.length));
  }
  if (columnLower.includes("utm_campaign") || columnName.includes("utm campaign")) {
    const campaigns = [
      "Summer Sale", "Black Friday", "New Product Launch", "Holiday Special",
      "Referral Program", "Newsletter Signup", "Brand Awareness"
    ];
    return campaigns.slice(0, Math.min(groupCount, campaigns.length));
  }
  if (columnLower.includes("referrer") || columnName.includes("referrer")) {
    const referrers = [
      "google.com", "facebook.com", "twitter.com", "linkedin.com",
      "direct", "newsletter", "partner-site.com"
    ];
    return referrers.slice(0, Math.min(groupCount, referrers.length));
  }
  if (columnLower.includes("currency") || columnName.includes("currency")) {
    const currencies = ["USD", "EUR", "GBP", "JPY", "CAD", "AUD", "CHF"];
    return currencies.slice(0, Math.min(groupCount, currencies.length));
  }
  if (columnLower.includes("event") && columnLower.includes("name")) {
    const events = [
      "Page View", "Purchase", "Sign Up", "Login", "Add to Cart",
      "Checkout Started", "Video Played", "Download"
    ];
    return events.slice(0, Math.min(groupCount, events.length));
  }
  if (columnLower.includes("product") && columnName.includes("name")) {
    const products = [
      "Product Alpha", "Product Beta", "Product Gamma", "Product Delta",
      "Product Epsilon", "Product Zeta", "Product Eta"
    ];
    return products.slice(0, Math.min(groupCount, products.length));
  }
  if (columnDef?.datatype === "string") {
    if (columnLower.includes("status") || columnLower.includes("state")) {
      const states = ["Active", "Inactive", "Pending", "Completed", "Cancelled"];
      return states.slice(0, Math.min(groupCount, states.length));
    }
    if (columnLower.includes("type") || columnLower.includes("kind")) {
      return Array.from({ length: groupCount }, (_, i) =>
        `Type ${String.fromCharCode(65 + i)}`
      );
    }
    if (columnLower.includes("name") || columnLower.includes("title")) {
      return Array.from({ length: groupCount }, (_, i) =>
        `${columnDef?.name || column} ${String.fromCharCode(65 + i)}`
      );
    }
    return Array.from({ length: groupCount }, (_, i) =>
      `${columnDef?.name || column} ${i + 1}`
    );
  }
  if (columnDef?.datatype === "number") {
    const baseValue = 10;
    return Array.from({ length: groupCount }, (_, i) =>
      String(baseValue * (i + 1))
    );
  }
  if (columnDef?.datatype === "date") {
    const dates = Array.from({ length: groupCount }, (_, i) => {
      const date = new Date();
      date.setDate(date.getDate() - (groupCount - i) * 7);
      return date.toISOString().split("T")[0];
    });
    return dates;
  }
  return Array.from({ length: groupCount }, (_, i) =>
    `${columnDef?.name || column} ${String.fromCharCode(65 + i)}`
  );
}
*/