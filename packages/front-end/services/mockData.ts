import {
  FactTableInterface,
  FactMetricInterface,
} from "shared/types/fact-table";
import type { RowFilter } from "shared/types/fact-table";
import { ExploreDataPoint } from "shared/enterprise";
import type {
  ProductAnalyticsConfig,
  ProductAnalyticsDataset,
  ProductAnalyticsResult,
  ProductAnalyticsValue,
} from "shared/validators";

// ---------------------------------------------------------------------------
// Hardcoded mock data (generated by scripts/generate-mock-data-json.ts)
// Loaded synchronously when available; no random/generated fallback (empty data only).
// ---------------------------------------------------------------------------
export type FactTableRow = Record<string, unknown>;
export type HardcodedMockData = {
  factTables: Record<string, FactTableRow[]>;
  metrics: Record<string, ExploreDataPoint[]>;
};

let _hardcodedData: HardcodedMockData | null | undefined = undefined;

function getHardcodedData(): HardcodedMockData | null {
  if (_hardcodedData !== undefined) return _hardcodedData;
  try {
    const dummyFactTable =
      require("./mockData/factTables/dummy_fact_table.json") as FactTableRow[];
    const dummyPurchasesTable =
      require("./mockData/factTables/dummy_purchases_table.json") as FactTableRow[];
    const dummySessionsTable =
      require("./mockData/factTables/dummy_sessions_table.json") as FactTableRow[];
    const dummyFactMetric1 =
      require("./mockData/metrics/dummy_fact_metric_1.json") as ExploreDataPoint[];
    const dummyFactMetric2 =
      require("./mockData/metrics/dummy_fact_metric_2.json") as ExploreDataPoint[];
    _hardcodedData = {
      factTables: {
        dummy_fact_table: dummyFactTable,
        dummy_purchases_table: dummyPurchasesTable,
        dummy_sessions_table: dummySessionsTable,
      },
      metrics: {
        dummy_fact_metric_1: dummyFactMetric1,
        dummy_fact_metric_2: dummyFactMetric2,
      },
    };
    return _hardcodedData;
  } catch {
    _hardcodedData = null;
    return null;
  }
}

// Create dummy fact tables for testing/development
export function createDummyFactTables(): FactTableInterface[] {
  const now = new Date();

  return [
    {
      id: "dummy_fact_table",
      organization: "dummy_org",
      dateCreated: now,
      dateUpdated: now,
      name: "Dummy Events",
      description: "A dummy fact table for testing purposes",
      owner: "dummy_owner",
      projects: [],
      tags: [],
      datasource: "dummy_datasource",
      userIdTypes: ["user_id", "anonymous_id"],
      sql: `SELECT 
  timestamp,
  user_id,
  anonymous_id,
  event_name,
  properties
FROM events
WHERE timestamp BETWEEN '{{startDate}}' AND '{{endDate}}'`,
      eventName: "dummy_event",
      columns: [
        {
          dateCreated: now,
          dateUpdated: now,
          name: "Timestamp",
          description: "Event timestamp",
          column: "timestamp",
          datatype: "date",
          numberFormat: "",
          deleted: false,
        },
        {
          dateCreated: now,
          dateUpdated: now,
          name: "User ID",
          description: "User identifier",
          column: "user_id",
          datatype: "string",
          numberFormat: "",
          deleted: false,
        },
        {
          dateCreated: now,
          dateUpdated: now,
          name: "Anonymous ID",
          description: "Anonymous identifier",
          column: "anonymous_id",
          datatype: "string",
          numberFormat: "",
          deleted: false,
        },
        {
          dateCreated: now,
          dateUpdated: now,
          name: "Event Name",
          description: "Name of the event",
          column: "event_name",
          datatype: "string",
          numberFormat: "",
          deleted: false,
          alwaysInlineFilter: true,
        },
        {
          dateCreated: now,
          dateUpdated: now,
          name: "Properties",
          description: "Event properties",
          column: "properties",
          datatype: "json",
          numberFormat: "",
          deleted: false,
        },
      ],
      filters: [],
      archived: false,
    },
    {
      id: "dummy_purchases_table",
      organization: "dummy_org",
      dateCreated: now,
      dateUpdated: now,
      name: "Purchases",
      description: "E-commerce purchase transactions",
      owner: "dummy_owner",
      projects: [],
      tags: [],
      datasource: "dummy_datasource",
      userIdTypes: ["user_id", "customer_id"],
      sql: `SELECT 
  purchase_date as timestamp,
  user_id,
  customer_id,
  order_id,
  product_id,
  product_name,
  category,
  amount,
  quantity,
  currency,
  payment_method,
  shipping_country
FROM purchases
WHERE purchase_date BETWEEN '{{startDate}}' AND '{{endDate}}'
  AND status = 'completed'`,
      eventName: "purchase",
      columns: [
        {
          dateCreated: now,
          dateUpdated: now,
          name: "Timestamp",
          description: "Purchase timestamp",
          column: "timestamp",
          datatype: "date",
          numberFormat: "",
          deleted: false,
        },
        {
          dateCreated: now,
          dateUpdated: now,
          name: "User ID",
          description: "User identifier",
          column: "user_id",
          datatype: "string",
          numberFormat: "",
          deleted: false,
        },
        {
          dateCreated: now,
          dateUpdated: now,
          name: "Customer ID",
          description: "Customer identifier",
          column: "customer_id",
          datatype: "string",
          numberFormat: "",
          deleted: false,
        },
        {
          dateCreated: now,
          dateUpdated: now,
          name: "Order ID",
          description: "Order identifier",
          column: "order_id",
          datatype: "string",
          numberFormat: "",
          deleted: false,
        },
        {
          dateCreated: now,
          dateUpdated: now,
          name: "Product ID",
          description: "Product identifier",
          column: "product_id",
          datatype: "string",
          numberFormat: "",
          deleted: false,
        },
        {
          dateCreated: now,
          dateUpdated: now,
          name: "Product Name",
          description: "Name of the product",
          column: "product_name",
          datatype: "string",
          numberFormat: "",
          deleted: false,
        },
        {
          dateCreated: now,
          dateUpdated: now,
          name: "Category",
          description: "Product category",
          column: "category",
          datatype: "string",
          numberFormat: "",
          deleted: false,
          alwaysInlineFilter: true,
        },
        {
          dateCreated: now,
          dateUpdated: now,
          name: "Amount",
          description: "Purchase amount",
          column: "amount",
          datatype: "number",
          numberFormat: "currency",
          deleted: false,
        },
        {
          dateCreated: now,
          dateUpdated: now,
          name: "Quantity",
          description: "Quantity purchased",
          column: "quantity",
          datatype: "number",
          numberFormat: "",
          deleted: false,
        },
        {
          dateCreated: now,
          dateUpdated: now,
          name: "Currency",
          description: "Currency code",
          column: "currency",
          datatype: "string",
          numberFormat: "",
          deleted: false,
        },
        {
          dateCreated: now,
          dateUpdated: now,
          name: "Payment Method",
          description: "Payment method used",
          column: "payment_method",
          datatype: "string",
          numberFormat: "",
          deleted: false,
        },
        {
          dateCreated: now,
          dateUpdated: now,
          name: "Shipping Country",
          description: "Shipping country",
          column: "shipping_country",
          datatype: "string",
          numberFormat: "",
          deleted: false,
        },
      ],
      filters: [],
      archived: false,
    },
    {
      id: "dummy_sessions_table",
      organization: "dummy_org",
      dateCreated: now,
      dateUpdated: now,
      name: "User Sessions",
      description: "User session tracking data",
      owner: "dummy_owner",
      projects: [],
      tags: [],
      datasource: "dummy_datasource",
      userIdTypes: ["user_id", "session_id"],
      sql: `SELECT 
  session_start as timestamp,
  user_id,
  session_id,
  session_duration_seconds,
  page_views,
  events_count,
  referrer,
  utm_source,
  utm_medium,
  utm_campaign,
  device_type,
  browser,
  os,
  country
FROM user_sessions
WHERE session_start BETWEEN '{{startDate}}' AND '{{endDate}}'`,
      eventName: "session_start",
      columns: [
        {
          dateCreated: now,
          dateUpdated: now,
          name: "Timestamp",
          description: "Session start timestamp",
          column: "timestamp",
          datatype: "date",
          numberFormat: "",
          deleted: false,
        },
        {
          dateCreated: now,
          dateUpdated: now,
          name: "User ID",
          description: "User identifier",
          column: "user_id",
          datatype: "string",
          numberFormat: "",
          deleted: false,
        },
        {
          dateCreated: now,
          dateUpdated: now,
          name: "Session ID",
          description: "Session identifier",
          column: "session_id",
          datatype: "string",
          numberFormat: "",
          deleted: false,
        },
        {
          dateCreated: now,
          dateUpdated: now,
          name: "Session Duration",
          description: "Session duration in seconds",
          column: "session_duration_seconds",
          datatype: "number",
          numberFormat: "time:seconds",
          deleted: false,
        },
        {
          dateCreated: now,
          dateUpdated: now,
          name: "Page Views",
          description: "Number of page views in session",
          column: "page_views",
          datatype: "number",
          numberFormat: "",
          deleted: false,
        },
        {
          dateCreated: now,
          dateUpdated: now,
          name: "Events Count",
          description: "Total events in session",
          column: "events_count",
          datatype: "number",
          numberFormat: "",
          deleted: false,
        },
        {
          dateCreated: now,
          dateUpdated: now,
          name: "Referrer",
          description: "Referrer URL",
          column: "referrer",
          datatype: "string",
          numberFormat: "",
          deleted: false,
        },
        {
          dateCreated: now,
          dateUpdated: now,
          name: "UTM Source",
          description: "UTM source parameter",
          column: "utm_source",
          datatype: "string",
          numberFormat: "",
          deleted: false,
        },
        {
          dateCreated: now,
          dateUpdated: now,
          name: "UTM Medium",
          description: "UTM medium parameter",
          column: "utm_medium",
          datatype: "string",
          numberFormat: "",
          deleted: false,
        },
        {
          dateCreated: now,
          dateUpdated: now,
          name: "UTM Campaign",
          description: "UTM campaign parameter",
          column: "utm_campaign",
          datatype: "string",
          numberFormat: "",
          deleted: false,
        },
        {
          dateCreated: now,
          dateUpdated: now,
          name: "Device Type",
          description: "Device type (mobile, desktop, tablet)",
          column: "device_type",
          datatype: "string",
          numberFormat: "",
          deleted: false,
          alwaysInlineFilter: true,
        },
        {
          dateCreated: now,
          dateUpdated: now,
          name: "Browser",
          description: "Browser name",
          column: "browser",
          datatype: "string",
          numberFormat: "",
          deleted: false,
        },
        {
          dateCreated: now,
          dateUpdated: now,
          name: "OS",
          description: "Operating system",
          column: "os",
          datatype: "string",
          numberFormat: "",
          deleted: false,
        },
        {
          dateCreated: now,
          dateUpdated: now,
          name: "Country",
          description: "User country",
          column: "country",
          datatype: "string",
          numberFormat: "",
          deleted: false,
        },
      ],
      filters: [],
      archived: false,
    },
  ];
}

// Create dummy fact metrics for testing/development
export function createDummyFactMetrics(): FactMetricInterface[] {
  const now = new Date();
  const dummyFactTableId = "dummy_fact_table";

  return [
    {
      id: "dummy_fact_metric_1",
      organization: "dummy_org",
      dateCreated: now,
      dateUpdated: now,
      name: "Page Views",
      description: "A dummy metric for page views",
      owner: "dummy_owner",
      projects: [],
      tags: [],
      datasource: "dummy_datasource",
      metricType: "mean",
      numerator: {
        factTableId: dummyFactTableId,
        column: "$$count",
        rowFilters: [
          {
            column: "event_name",
            operator: "=",
            values: ["Page View"],
          },
        ],
      },
      denominator: null,
      inverse: false,
      cappingSettings: {
        type: "",
        value: 1000,
        ignoreZeros: false,
      },
      windowSettings: {
        type: "",
        delayValue: 1,
        delayUnit: "days",
        windowValue: 1,
        windowUnit: "days",
      },
      priorSettings: {
        override: false,
        proper: false,
        mean: 0,
        stddev: 1,
      },
      quantileSettings: null,
      maxPercentChange: 100,
      minPercentChange: 0.1,
      minSampleSize: 100,
      targetMDE: 0.1,
      displayAsPercentage: false,
      winRisk: 0.1,
      loseRisk: 0.05,
      regressionAdjustmentOverride: true,
      regressionAdjustmentEnabled: false,
      regressionAdjustmentDays: 10,
      archived: false,
    },
    {
      id: "dummy_fact_metric_2",
      organization: "dummy_org",
      dateCreated: now,
      dateUpdated: now,
      name: "Conversion Rate",
      description: "A dummy ratio metric for conversion rate",
      owner: "dummy_owner",
      projects: [],
      tags: [],
      datasource: "dummy_datasource",
      metricType: "ratio",
      numerator: {
        factTableId: dummyFactTableId,
        column: "$$count",
        rowFilters: [
          {
            column: "event_name",
            operator: "=",
            values: ["Purchase"],
          },
        ],
      },
      denominator: {
        factTableId: dummyFactTableId,
        column: "$$count",
        rowFilters: [
          {
            column: "event_name",
            operator: "=",
            values: ["Page View"],
          },
        ],
      },
      inverse: false,
      cappingSettings: {
        type: "",
        value: 1000,
        ignoreZeros: false,
      },
      windowSettings: {
        type: "",
        delayValue: 1,
        delayUnit: "days",
        windowValue: 1,
        windowUnit: "days",
      },
      priorSettings: {
        override: false,
        proper: false,
        mean: 0,
        stddev: 1,
      },
      quantileSettings: null,
      maxPercentChange: 100,
      minPercentChange: 0.1,
      minSampleSize: 100,
      targetMDE: 0.1,
      displayAsPercentage: true,
      winRisk: 0.1,
      loseRisk: 0.05,
      regressionAdjustmentOverride: true,
      regressionAdjustmentEnabled: false,
      regressionAdjustmentDays: 10,
      archived: false,
    },
  ];
}

// ---------------------------------------------------------------------------
// Helpers for hardcoded data: date extraction, filtering, aggregation
// ---------------------------------------------------------------------------
function getDateFromRow(row: FactTableRow, dateColumn: string): string {
  const v = row[dateColumn];
  if (v == null) return "";
  if (typeof v === "string") {
    return v.slice(0, 10);
  }
  if (typeof v === "number") return new Date(v).toISOString().slice(0, 10);
  return "";
}

function getDateBucket(dateStr: string, granularity: string): string {
  if (!dateStr || dateStr.length < 10) return dateStr;
  const d = new Date(dateStr + "T00:00:00Z");
  if (granularity === "day") return dateStr;
  if (granularity === "week") {
    const day = d.getUTCDay();
    const monday = new Date(d);
    monday.setUTCDate(d.getUTCDate() - (day === 0 ? 6 : day - 1));
    return monday.toISOString().slice(0, 10);
  }
  if (granularity === "month") return dateStr.slice(0, 7);
  if (granularity === "year") return dateStr.slice(0, 4);
  return dateStr;
}

function rowMatchesFilter(row: FactTableRow, filter: RowFilter): boolean {
  const col = filter.column;
  const val = col != null ? row[col] : undefined;
  const strVal = val == null ? "" : String(val);
  const numVal = typeof val === "number" ? val : Number(val);
  const values = filter.values ?? [];
  const op = filter.operator;

  switch (op) {
    case "=":
      return values.length > 0 && values.some((v) => strVal === v);
    case "!=":
      return values.length === 0 || !values.some((v) => strVal === v);
    case "in":
      return values.some((v) => strVal === v);
    case "not_in":
      return !values.some((v) => strVal === v);
    case "contains":
      return values.some((v) => strVal.includes(v));
    case "not_contains":
      return values.length === 0 || !values.some((v) => strVal.includes(v));
    case "starts_with":
      return values.some((v) => strVal.startsWith(v));
    case "ends_with":
      return values.some((v) => strVal.endsWith(v));
    case "<":
      return (
        values.length > 0 && !Number.isNaN(numVal) && numVal < Number(values[0])
      );
    case "<=":
      return (
        values.length > 0 &&
        !Number.isNaN(numVal) &&
        numVal <= Number(values[0])
      );
    case ">":
      return (
        values.length > 0 && !Number.isNaN(numVal) && numVal > Number(values[0])
      );
    case ">=":
      return (
        values.length > 0 &&
        !Number.isNaN(numVal) &&
        numVal >= Number(values[0])
      );
    case "is_null":
      return val == null || strVal === "";
    case "not_null":
      return val != null && strVal !== "";
    case "is_true":
      return val === true || strVal.toLowerCase() === "true";
    case "is_false":
      return val === false || strVal.toLowerCase() === "false";
    default:
      return true;
  }
}

function filterRows(
  rows: FactTableRow[],
  dateColumn: string,
  startDateStr: string,
  endDateStr: string,
  globalFilters: RowFilter[] | undefined,
  seriesFilters: RowFilter[] | undefined,
): FactTableRow[] {
  return rows.filter((row) => {
    const dateStr = getDateFromRow(row, dateColumn);
    if (dateStr < startDateStr || dateStr > endDateStr) return false;
    for (const f of globalFilters ?? []) {
      if (!rowMatchesFilter(row, f)) return false;
    }
    for (const f of seriesFilters ?? []) {
      if (!rowMatchesFilter(row, f)) return false;
    }
    return true;
  });
}

function getDateColumnForFactTable(factTableId: string): string {
  const tables = createDummyFactTables();
  const t = tables.find((x) => x.id === factTableId);
  const dateCol = t?.columns.find((c) => c.datatype === "date");
  return dateCol?.column ?? "timestamp";
}

type AggregatedBucket = { value: number; units: number };
type TimeSeriesBucket = { bucket: string; value: number; units: number };

function aggregateFactTableRows(
  rows: FactTableRow[],
  dateColumn: string,
  valueType: "count" | "unit_count" | "sum",
  unitColumn: string | undefined,
  valueColumn: string | undefined,
  groupByColumn: string | undefined,
  granularity: string,
  asTimeSeries: boolean,
): TimeSeriesBucket[] | Record<string, AggregatedBucket> {
  const unitCol = unitColumn ?? "user_id";

  if (asTimeSeries) {
    const byBucket = new Map<
      string,
      { value: number; units: Set<string> | number; sum?: number }
    >();
    for (const row of rows) {
      const dateStr = getDateFromRow(row, dateColumn);
      const bucket = getDateBucket(dateStr, granularity);
      if (!bucket) continue;
      let entry = byBucket.get(bucket);
      if (!entry) {
        entry =
          valueType === "unit_count"
            ? { value: 0, units: new Set<string>() }
            : valueType === "count"
              ? { value: 0, units: 0 }
              : { value: 0, units: 0, sum: 0 };
        byBucket.set(bucket, entry);
      }
      if (valueType === "unit_count") {
        const u = String(row[unitCol] ?? "");
        (entry.units as Set<string>).add(u);
        entry.value = (entry.units as Set<string>).size;
      } else if (valueType === "count") {
        entry.value += 1;
        (entry as { units: number }).units += 1;
      } else {
        const v = Number(row[valueColumn ?? ""] ?? 0);
        entry.value += v;
        (entry as { sum: number }).sum =
          ((entry as { sum?: number }).sum ?? 0) + v;
        (entry as { units: number }).units =
          ((entry as { units: number }).units ?? 0) + 1;
      }
    }
    const sortedBuckets = Array.from(byBucket.keys()).sort();
    const result: TimeSeriesBucket[] = [];
    for (const bucket of sortedBuckets) {
      const e = byBucket.get(bucket)!;
      let value = e.value;
      let units: number;
      if (valueType === "unit_count") {
        units = (e.units as Set<string>).size;
        value = units;
      } else if (valueType === "sum") {
        units = (e as { units: number }).units;
        value = (e as { sum: number }).sum ?? 0;
      } else {
        units = (e.units as number) ?? value;
      }
      result.push({ bucket, value, units });
    }
    return result;
  }

  const byGroup = new Map<
    string,
    { value: number; units: Set<string> | number; sum?: number }
  >();
  const groupCol = groupByColumn ?? "";
  for (const row of rows) {
    const group = groupCol ? String(row[groupCol] ?? "") : "_total";
    let entry = byGroup.get(group);
    if (!entry) {
      entry =
        valueType === "unit_count"
          ? { value: 0, units: new Set<string>() }
          : valueType === "count"
            ? { value: 0, units: 0 }
            : { value: 0, units: 0, sum: 0 };
      byGroup.set(group, entry);
    }
    if (valueType === "unit_count") {
      const u = String(row[unitCol] ?? "");
      (entry.units as Set<string>).add(u);
      entry.value = (entry.units as Set<string>).size;
    } else if (valueType === "count") {
      entry.value += 1;
      (entry as { units: number }).units += 1;
    } else {
      const v = Number(row[valueColumn ?? ""] ?? 0);
      entry.value += v;
      (entry as { sum: number }).sum =
        ((entry as { sum?: number }).sum ?? 0) + v;
      (entry as { units: number }).units =
        ((entry as { units: number }).units ?? 0) + 1;
    }
  }
  const out: Record<string, AggregatedBucket> = {};
  for (const [group, e] of byGroup) {
    let value = e.value;
    let units: number;
    if (valueType === "unit_count") {
      units = (e.units as Set<string>).size;
      value = units;
    } else if (valueType === "sum") {
      units = (e as { units: number }).units;
      value = (e as { sum: number }).sum ?? 0;
    } else {
      units = (e.units as number) ?? value;
    }
    out[group] = { value, units };
  }
  return out;
}

function aggregateMetricRows(
  points: ExploreDataPoint[],
  startDateStr: string,
  endDateStr: string,
  granularity: string,
  asSingleTotal: boolean,
): ExploreDataPoint[] | ExploreDataPoint {
  const filtered = points.filter(
    (p) => p.date >= startDateStr && p.date <= endDateStr,
  );
  if (asSingleTotal) {
    let numerator = 0;
    let denominator = 0;
    let units = 0;
    for (const p of filtered) {
      numerator += p.numerator ?? p.mean * (p.units || 1);
      denominator += p.denominator ?? 0;
      units += p.units ?? 0;
    }
    const value = numerator;
    const mean = units > 0 ? value / units : 0;
    return {
      date: startDateStr,
      units,
      mean,
      stddev: mean * 0.1,
      numerator: value,
      ...(denominator ? { denominator } : {}),
    };
  }
  const byBucket = new Map<
    string,
    { numerator: number; denominator: number; units: number; count: number }
  >();
  for (const p of filtered) {
    const bucket = getDateBucket(p.date, granularity);
    let entry = byBucket.get(bucket);
    if (!entry) {
      entry = { numerator: 0, denominator: 0, units: 0, count: 0 };
      byBucket.set(bucket, entry);
    }
    entry.numerator += p.numerator ?? p.mean * (p.units || 1);
    entry.denominator += p.denominator ?? 0;
    entry.units += p.units ?? 0;
    entry.count += 1;
  }
  const result: ExploreDataPoint[] = [];
  const sorted = Array.from(byBucket.keys()).sort();
  for (const bucket of sorted) {
    const e = byBucket.get(bucket)!;
    const value = e.numerator;
    const mean = e.denominator
      ? value / e.denominator
      : e.units
        ? value / e.units
        : 0;
    result.push({
      date: bucket,
      units: e.units,
      mean,
      stddev: mean * 0.1,
      numerator: value,
      ...(e.denominator ? { denominator: e.denominator } : {}),
    });
  }
  return result;
}

/** Compute date range strings from ProductAnalyticsConfig.dateRange */
function getDateRangeFromConfig(config: ProductAnalyticsConfig): {
  startDateStr: string;
  endDateStr: string;
} {
  const dr = config.dateRange;
  const endDate = new Date();
  let startDate = new Date();

  if (dr.predefined === "customDateRange" && dr.startDate && dr.endDate) {
    return {
      startDateStr: dr.startDate.toISOString().split("T")[0],
      endDateStr: dr.endDate.toISOString().split("T")[0],
    };
  }
  if (
    dr.predefined === "customLookback" &&
    dr.lookbackValue != null &&
    dr.lookbackUnit
  ) {
    const n = dr.lookbackValue;
    if (dr.lookbackUnit === "hour") startDate.setHours(startDate.getHours() - n);
    else if (dr.lookbackUnit === "day") startDate.setDate(startDate.getDate() - n);
    else if (dr.lookbackUnit === "week") startDate.setDate(startDate.getDate() - n * 7);
    else if (dr.lookbackUnit === "month") startDate.setMonth(startDate.getMonth() - n);
  } else {
    if (dr.predefined === "today") startDate = new Date(endDate);
    else if (dr.predefined === "last7Days") startDate.setDate(startDate.getDate() - 7);
    else if (dr.predefined === "last30Days") startDate.setDate(startDate.getDate() - 30);
    else if (dr.predefined === "last90Days") startDate.setDate(startDate.getDate() - 90);
  }
  return {
    startDateStr: startDate.toISOString().split("T")[0],
    endDateStr: endDate.toISOString().split("T")[0],
  };
}

/** Get date granularity from config dimensions (first date dimension, else "day") */
function getGranularityFromConfig(config: ProductAnalyticsConfig): string {
  const dateDim = config.dimensions.find((d) => d.dimensionType === "date");
  if (dateDim && dateDim.dimensionType === "date") {
    const g = dateDim.dateGranularity;
    return g === "auto" ? "day" : g;
  }
  return "day";
}

/** Get group-by column from config dimensions (first dynamic or static dimension) */
function getGroupByColumnFromConfig(config: ProductAnalyticsConfig): string | undefined {
  const dim = config.dimensions.find(
    (d) => d.dimensionType === "dynamic" || d.dimensionType === "static",
  );
  if (dim && (dim.dimensionType === "dynamic" || dim.dimensionType === "static"))
    return dim.column;
  return undefined;
}

/** Get metricId for a value in ProductAnalyticsResult rows */
function getMetricIdForValue(
  value: ProductAnalyticsValue,
  _dataset: ProductAnalyticsDataset | null,
): string {
  if (value.type === "metric") return value.metricId;
  return value.name;
}

/**
 * Generates mock explore data based on ProductAnalyticsConfig.
 * This emulates the API response from the backend (ProductAnalyticsResult format).
 */
export function generateMockExploreData(
  config: ProductAnalyticsConfig,
): ProductAnalyticsResult {
  const dataset = config.dataset;
  const values = dataset?.values ?? [];
  const { chartType, dimensions } = config;

  const { startDateStr, endDateStr } = getDateRangeFromConfig(config);
  const gran = getGranularityFromConfig(config);
  const groupByCol = getGroupByColumnFromConfig(config);

  const data = getHardcodedData();
  const useHardcoded = data != null && values.length > 0;

  const HARDCODED_DATA_START = "2024-01-01";
  const HARDCODED_DATA_END = "2025-12-31";
  let effectiveStartStr = startDateStr;
  let effectiveEndStr = endDateStr;
  if (useHardcoded) {
    if (effectiveStartStr < HARDCODED_DATA_START)
      effectiveStartStr = HARDCODED_DATA_START;
    if (effectiveEndStr > HARDCODED_DATA_END)
      effectiveEndStr = HARDCODED_DATA_END;
    if (effectiveStartStr > effectiveEndStr) {
      effectiveStartStr = HARDCODED_DATA_START;
      effectiveEndStr = HARDCODED_DATA_END;
    }
    if (
      typeof process !== "undefined" &&
      process.env?.NODE_ENV === "development"
    ) {
      // eslint-disable-next-line no-console
      console.log("[mockData] generateMockExploreData", {
        useHardcoded,
        chartType,
        groupByCol,
        requestedRange: { startDateStr, endDateStr },
        effectiveRange: { effectiveStartStr, effectiveEndStr },
      });
    }
  }

  if (!useHardcoded) return { rows: [] };

  // Single total row (table with no dimensions, or first value only for big-number-like)
  const isTimeSeries = chartType === "line" || chartType === "area";
  const isBar = chartType === "bar";

  if (!isTimeSeries && !isBar) {
    // table or single metric: one row "_total" with one value per series
    const firstValue = values[0];
    if (!firstValue) return { rows: [] };

    if (firstValue.type === "metric") {
      const metricRows = data.metrics[firstValue.metricId];
      if (metricRows) {
        const single = aggregateMetricRows(
          metricRows,
          effectiveStartStr,
          effectiveEndStr,
          gran,
          true,
        ) as ExploreDataPoint;
        const value = single.numerator ?? single.mean * single.units;
        const denominator = single.denominator ?? null;
        return {
          rows: [
            {
              dimensions: ["_total"],
              values: [
                {
                  metricId: getMetricIdForValue(firstValue, dataset),
                  value,
                  denominator,
                },
              ],
            },
          ],
        };
        }
      }
    if (firstValue.type === "fact_table" && dataset?.type === "fact_table") {
      const tableId = dataset.factTableId;
      const rows = data.factTables[tableId];
      if (rows) {
        const dateCol = getDateColumnForFactTable(tableId);
        const valueType = firstValue.valueType ?? "count";
        const filtered = filterRows(
          rows,
          dateCol,
          effectiveStartStr,
          effectiveEndStr,
          undefined,
          firstValue.rowFilters,
        );
        const agg = aggregateFactTableRows(
          filtered,
          dateCol,
          valueType,
          undefined,
          firstValue.valueColumn ?? undefined,
          undefined,
          gran,
          false,
        ) as Record<string, AggregatedBucket>;
        const total = agg["_total"] ?? Object.values(agg)[0];
        const value = total?.value ?? 0;
        return {
          rows: [
            {
              dimensions: ["_total"],
              values: [
                {
                  metricId: getMetricIdForValue(firstValue, dataset),
                  value,
                  denominator: null,
                },
              ],
            },
          ],
        };
        }
      }
    return { rows: [] };
  }

  if (isBar) {
    const seriesGroups: {
      metricId: string;
      byGroup: Map<string, { value: number; denominator: number | null }>;
    }[] = [];

    for (const val of values) {
      const metricId = getMetricIdForValue(val, dataset);
      const byGroup = new Map<string, { value: number; denominator: number | null }>();

      if (val.type === "metric") {
        const metricRows = data.metrics[val.metricId];
        if (metricRows) {
          const filtered = metricRows.filter(
            (p) => p.date >= effectiveStartStr && p.date <= effectiveEndStr,
          );
          const acc = new Map<string, { numerator: number; denominator: number }>();
          for (const p of filtered) {
            const group = "_total";
            let e = acc.get(group);
            if (!e) {
              e = { numerator: 0, denominator: 0 };
              acc.set(group, e);
            }
            e.numerator += p.numerator ?? p.mean * (p.units || 1);
            e.denominator += p.denominator ?? 0;
          }
          for (const [group, e] of acc) {
            byGroup.set(group, {
              value: e.numerator,
              denominator: e.denominator || null,
            });
          }
        }
      } else if (val.type === "fact_table" && dataset?.type === "fact_table") {
        const tableId = dataset.factTableId;
        const rows = data.factTables[tableId];
        if (rows) {
          const dateCol = getDateColumnForFactTable(tableId);
          const valueType = val.valueType ?? "count";
          const filtered = filterRows(
            rows,
            dateCol,
            effectiveStartStr,
            effectiveEndStr,
            undefined,
            val.rowFilters,
          );
          const agg = aggregateFactTableRows(
            filtered,
            dateCol,
            valueType,
            undefined,
            val.valueColumn ?? undefined,
            groupByCol,
            gran,
            false,
          ) as Record<string, AggregatedBucket>;
          for (const [group, b] of Object.entries(agg)) {
            if (group === "_total" && groupByCol) continue;
            byGroup.set(group, { value: b.value, denominator: null });
          }
        }
      }
      seriesGroups.push({ metricId, byGroup });
    }

    const allGroupNames = new Set<string>();
    for (const { byGroup } of seriesGroups) {
      for (const g of byGroup.keys()) allGroupNames.add(g);
    }
    const sortedGroups = Array.from(allGroupNames).sort();

    return {
      rows: sortedGroups.map((group) => ({
        dimensions: [group],
        values: seriesGroups.map(({ metricId, byGroup }) => {
          const e = byGroup.get(group);
          return {
            metricId,
            value: e?.value ?? 0,
            denominator: e?.denominator ?? null,
          };
        }),
      })),
    };
  }

  // line / area: time series
  type DateEntry = { value: number; denominator: number | null };
  const seriesByDate: {
    metricId: string;
    byDate: Map<string, DateEntry>;
  }[] = [];

  for (const val of values) {
    const metricId = getMetricIdForValue(val, dataset);
    const byDate = new Map<string, DateEntry>();

    if (val.type === "metric") {
      const metricRows = data.metrics[val.metricId];
      if (metricRows) {
        const points = aggregateMetricRows(
          metricRows,
          startDateStr,
          endDateStr,
          gran,
          false,
        ) as ExploreDataPoint[];
        for (const p of points) {
          byDate.set(p.date, {
            value: p.numerator ?? p.mean * (p.units || 1),
            denominator: p.denominator ?? null,
          });
        }
      }
    } else if (val.type === "fact_table" && dataset?.type === "fact_table") {
      const tableId = dataset.factTableId;
      const rows = data.factTables[tableId];
      if (rows) {
        const dateCol = getDateColumnForFactTable(tableId);
        const valueType = val.valueType ?? "count";
        const filtered = filterRows(
          rows,
          dateCol,
          startDateStr,
          endDateStr,
          undefined,
          val.rowFilters,
        );
        const agg = aggregateFactTableRows(
          filtered,
          dateCol,
          valueType,
          undefined,
          val.valueColumn ?? undefined,
          undefined,
          gran,
          true,
        ) as TimeSeriesBucket[];
        for (const b of agg) {
          byDate.set(b.bucket, { value: b.value, denominator: null });
        }
      }
    }
    seriesByDate.push({ metricId, byDate });
  }

  const allDates = new Set<string>();
  for (const { byDate } of seriesByDate) {
    for (const d of byDate.keys()) allDates.add(d);
  }
  const sortedDates = Array.from(allDates).sort();

  return {
    rows: sortedDates.map((date) => ({
      dimensions: [date],
      values: seriesByDate.map(({ metricId, byDate }) => {
        const e = byDate.get(date);
        return {
          metricId,
          value: e?.value ?? 0,
          denominator: e?.denominator ?? null,
        };
      }),
    })),
  };
}

/* ---------------------------------------------------------------------------
 * GENERATED MOCK DATA - COMMENTED OUT (use only hardcoded data from mockData/*.json)
 * ---------------------------------------------------------------------------
 * Helper function to generate realistic group names based on column type and fact table metadata
 *
function generateGroupNames(
  column: string,
  factTableId: string | null,
  count?: number
): string[] {
  const factTables = createDummyFactTables();
  const factTable = factTableId
    ? factTables.find((ft) => ft.id === factTableId)
    : null;
  const columnDef = factTable?.columns.find(
    (col) => col.column === column || col.name.toLowerCase().includes(column.toLowerCase())
  );
  const groupCount = count ?? Math.floor(3 + Math.random() * 6);
  const columnLower = column.toLowerCase();
  const columnName = columnDef?.name.toLowerCase() || columnLower;
  if (columnLower.includes("device") || columnName.includes("device")) {
    const devices = ["Mobile", "Desktop", "Tablet", "Smart TV", "Wearable"];
    return devices.slice(0, Math.min(groupCount, devices.length));
  }
  if (columnLower.includes("browser") || columnName.includes("browser")) {
    const browsers = ["Chrome", "Firefox", "Safari", "Edge", "Opera", "Brave", "Samsung Internet"];
    return browsers.slice(0, Math.min(groupCount, browsers.length));
  }
  if (columnLower.includes("os") || columnName.includes("operating system") ||
      (columnLower === "os" && !columnLower.includes("browser"))) {
    const oses = ["Windows", "macOS", "Linux", "iOS", "Android", "Chrome OS"];
    return oses.slice(0, Math.min(groupCount, oses.length));
  }
  if (columnLower.includes("country") || columnName.includes("country")) {
    const countries = [
      "United States", "United Kingdom", "Canada", "Germany", "France",
      "Australia", "Japan", "Brazil", "India", "Spain", "Italy", "Netherlands"
    ];
    return countries.slice(0, Math.min(groupCount, countries.length));
  }
  if (columnLower.includes("payment") || columnName.includes("payment")) {
    const methods = [
      "Credit Card", "Debit Card", "PayPal", "Apple Pay", "Google Pay",
      "Bank Transfer", "Cryptocurrency", "Cash on Delivery"
    ];
    return methods.slice(0, Math.min(groupCount, methods.length));
  }
  if (columnLower.includes("category") || columnName.includes("category")) {
    const categories = [
      "Electronics", "Clothing", "Food & Beverage", "Books", "Toys",
      "Home & Garden", "Sports", "Beauty", "Automotive", "Health"
    ];
    return categories.slice(0, Math.min(groupCount, categories.length));
  }
  if (columnLower.includes("utm_source") || columnName.includes("utm source")) {
    const sources = ["Google", "Facebook", "Twitter", "LinkedIn", "Email", "Direct", "Organic"];
    return sources.slice(0, Math.min(groupCount, sources.length));
  }
  if (columnLower.includes("utm_medium") || columnName.includes("utm medium")) {
    const mediums = ["cpc", "social", "email", "organic", "referral", "display", "affiliate"];
    return mediums.slice(0, Math.min(groupCount, mediums.length));
  }
  if (columnLower.includes("utm_campaign") || columnName.includes("utm campaign")) {
    const campaigns = [
      "Summer Sale", "Black Friday", "New Product Launch", "Holiday Special",
      "Referral Program", "Newsletter Signup", "Brand Awareness"
    ];
    return campaigns.slice(0, Math.min(groupCount, campaigns.length));
  }
  if (columnLower.includes("referrer") || columnName.includes("referrer")) {
    const referrers = [
      "google.com", "facebook.com", "twitter.com", "linkedin.com",
      "direct", "newsletter", "partner-site.com"
    ];
    return referrers.slice(0, Math.min(groupCount, referrers.length));
  }
  if (columnLower.includes("currency") || columnName.includes("currency")) {
    const currencies = ["USD", "EUR", "GBP", "JPY", "CAD", "AUD", "CHF"];
    return currencies.slice(0, Math.min(groupCount, currencies.length));
  }
  if (columnLower.includes("event") && columnLower.includes("name")) {
    const events = [
      "Page View", "Purchase", "Sign Up", "Login", "Add to Cart",
      "Checkout Started", "Video Played", "Download"
    ];
    return events.slice(0, Math.min(groupCount, events.length));
  }
  if (columnLower.includes("product") && columnName.includes("name")) {
    const products = [
      "Product Alpha", "Product Beta", "Product Gamma", "Product Delta",
      "Product Epsilon", "Product Zeta", "Product Eta"
    ];
    return products.slice(0, Math.min(groupCount, products.length));
  }
  if (columnDef?.datatype === "string") {
    if (columnLower.includes("status") || columnLower.includes("state")) {
      const states = ["Active", "Inactive", "Pending", "Completed", "Cancelled"];
      return states.slice(0, Math.min(groupCount, states.length));
    }
    if (columnLower.includes("type") || columnLower.includes("kind")) {
      return Array.from({ length: groupCount }, (_, i) =>
        `Type ${String.fromCharCode(65 + i)}`
      );
    }
    if (columnLower.includes("name") || columnLower.includes("title")) {
      return Array.from({ length: groupCount }, (_, i) =>
        `${columnDef?.name || column} ${String.fromCharCode(65 + i)}`
      );
    }
    return Array.from({ length: groupCount }, (_, i) =>
      `${columnDef?.name || column} ${i + 1}`
    );
  }
  if (columnDef?.datatype === "number") {
    const baseValue = 10;
    return Array.from({ length: groupCount }, (_, i) =>
      String(baseValue * (i + 1))
    );
  }
  if (columnDef?.datatype === "date") {
    const dates = Array.from({ length: groupCount }, (_, i) => {
      const date = new Date();
      date.setDate(date.getDate() - (groupCount - i) * 7);
      return date.toISOString().split("T")[0];
    });
    return dates;
  }
  return Array.from({ length: groupCount }, (_, i) =>
    `${columnDef?.name || column} ${String.fromCharCode(65 + i)}`
  );
}
*/
