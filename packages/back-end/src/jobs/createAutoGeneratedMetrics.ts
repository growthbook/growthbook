/* eslint-disable no-console */
import Agenda, { Job } from "agenda";
import uniqid from "uniqid";
import { cloneDeep } from "lodash";
import { getDataSourceById } from "../models/DataSourceModel";
import { insertMetrics } from "../models/MetricModel";
import { MetricInterface } from "../../types/metric";
import { getSourceIntegrationObject } from "../services/datasource";
import { logger } from "../util/logger";
import { AutoGeneratedMetric } from "../types/Integration";

const CREATE_AUTOGENERATED_METRICS_JOB_NAME = "createAutoGeneratedMetrics";

type CreateAutoGeneratedMetricsJob = Job<{
  organization: string;
  datasourceId: string;
  metricsToCreate: AutoGeneratedMetric[];
}>;

let agenda: Agenda;
export default function (ag: Agenda) {
  agenda = ag;

  agenda.define(
    CREATE_AUTOGENERATED_METRICS_JOB_NAME,
    async (job: CreateAutoGeneratedMetricsJob) => {
      const { datasourceId, organization, metricsToCreate } = job.attrs.data;

      try {
        const datasource = await getDataSourceById(datasourceId, organization);

        if (!datasource) throw new Error("No datasource");

        const schemaFormat = datasource.settings.schemaFormat || "custom";

        if (schemaFormat === "custom")
          throw new Error(
            `Unable to automatically generate metrics for a custom schema format.`
          );

        const integration = getSourceIntegrationObject(datasource);

        if (!integration.getSourceProperties().supportsAutoGeneratedMetrics)
          throw new Error(
            "Auto generated metrics not supported for this data source"
          );

        const metrics: Partial<MetricInterface>[] = [];
        for (const metric of metricsToCreate) {
          const baseMetric: Partial<MetricInterface> = {
            organization,
            datasource: datasourceId,
            name: metric.displayName,
            dateCreated: new Date(),
            dateUpdated: new Date(),
          };
          if (metric.createBinomialFromEvent) {
            const metricToCreate: Partial<MetricInterface> = cloneDeep(
              baseMetric
            );
            metricToCreate.id = uniqid("met_");
            metricToCreate.type = "binomial";
            metricToCreate.sql = metric.binomialSqlQuery;
            metrics.push(metricToCreate);
          }
          if (metric.createCountFromEvent) {
            const metricToCreate: Partial<MetricInterface> = cloneDeep(
              baseMetric
            );
            metricToCreate.id = uniqid("met_");
            metricToCreate.type = "count";
            metricToCreate.name = metric.countDisplayName;
            metricToCreate.sql = metric.countSqlQuery;
            metrics.push(metricToCreate);
          }
        }
        await insertMetrics(metrics);
      } catch (e) {
        logger.error(
          e,
          "Failed to generate automatic metrics. Reason: " + e.message
        );
      }
    }
  );
}

export async function queueCreateAutoGeneratedMetrics(
  datasourceId: string,
  organization: string,
  metricsToCreate: AutoGeneratedMetric[]
) {
  if (!datasourceId || !organization || !metricsToCreate) return;

  const job = agenda.create(CREATE_AUTOGENERATED_METRICS_JOB_NAME, {
    organization,
    datasourceId,
    metricsToCreate,
  }) as CreateAutoGeneratedMetricsJob;
  job.unique({ datasourceId, organization, metricsToCreate });
  job.schedule(new Date());
  await job.save();
}
