/* eslint-disable no-console */
import Agenda, { Job } from "agenda";
import uniqid from "uniqid";
import { AutoMetricToCreate } from "shared/types/integrations";
import { AuditUserLoggedIn } from "shared/types/audit";
import { getDataSourceById } from "back-end/src/models/DataSourceModel";
import { insertMetrics } from "back-end/src/models/MetricModel";
import { InsertMetricProps } from "back-end/types/metric";
import { getSourceIntegrationObject } from "back-end/src/services/datasource";
import { logger } from "back-end/src/util/logger";
import { insertAudit } from "back-end/src/models/AuditModel";
import { auditDetailsCreate } from "back-end/src/services/audit";
import { ExpandedMember } from "back-end/types/organization";
import { getContextForAgendaJobByOrgId } from "back-end/src/services/organizations";

const CREATE_AUTOGENERATED_METRICS_JOB_NAME = "createAutoGeneratedMetrics";

type CreateAutoGeneratedMetricsJob = Job<{
  organizationId: string;
  datasourceId: string;
  metricsToCreate: AutoMetricToCreate[];
  user: Omit<
    ExpandedMember,
    "role" | "verified" | "limitAccessByEnvironment" | "environments"
  >;
}>;

const createAutoGeneratedMetrics = async (
  job: CreateAutoGeneratedMetricsJob,
) => {
  const { datasourceId, organizationId, metricsToCreate, user } =
    job.attrs.data;

  const context = await getContextForAgendaJobByOrgId(organizationId);

  try {
    const datasource = await getDataSourceById(context, datasourceId);

    if (!datasource) throw new Error("No datasource");

    const schemaFormat = datasource.settings.schemaFormat || "custom";

    if (schemaFormat === "custom")
      throw new Error(
        `Unable to automatically generate metrics for a custom schema format.`,
      );

    const integration = getSourceIntegrationObject(context, datasource);

    if (!integration.getSourceProperties().supportsAutoGeneratedMetrics)
      throw new Error(
        "Auto generated metrics not supported for this data source",
      );

    const metrics: InsertMetricProps[] = [];

    metricsToCreate.forEach((metric) => {
      metrics.push({
        id: uniqid("met_"),
        organization: organizationId,
        datasource: datasourceId,
        dateCreated: new Date(),
        dateUpdated: new Date(),
        name: metric.name,
        type: metric.type,
        sql: metric.sql,
        userIdTypes: metric.userIdTypes,
      });
    });

    await insertMetrics(context, metrics);

    for (const metric of metrics) {
      await insertAudit({
        event: "metric.autocreate",
        entity: {
          object: "metric",
          id: metric.id,
        },
        organization: organizationId,
        dateCreated: metric.dateCreated ? metric.dateCreated : new Date(),
        details: auditDetailsCreate(metric),
        user,
      });
    }
  } catch (e) {
    logger.error(e, "Failed to generate automatic metrics.");
  }
};

let agenda: Agenda;
export default function (ag: Agenda) {
  agenda = ag;
  agenda.define(
    CREATE_AUTOGENERATED_METRICS_JOB_NAME,
    createAutoGeneratedMetrics,
  );
}

export async function queueCreateAutoGeneratedMetrics(
  datasourceId: string,
  organizationId: string,
  metricsToCreate: AutoMetricToCreate[],
  user: AuditUserLoggedIn,
) {
  if (!datasourceId || !organizationId || !metricsToCreate || !user) return;

  const job = agenda.create(CREATE_AUTOGENERATED_METRICS_JOB_NAME, {
    organizationId,
    datasourceId,
    metricsToCreate,
    user,
  }) as CreateAutoGeneratedMetricsJob;
  job.unique({ datasourceId, organizationId, metricsToCreate });
  job.schedule(new Date());
  await job.save();
}
