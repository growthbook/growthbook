/* eslint-disable no-console */
import Agenda, { Job } from "agenda";
import uniqid from "uniqid";
import { getDataSourceById } from "../models/DataSourceModel";
import { insertMetrics } from "../models/MetricModel";
import { MetricInterface, MetricType } from "../../types/metric";
import { getSourceIntegrationObject } from "../services/datasource";
import { logger } from "../util/logger";
import { insertAudit } from "../models/AuditModel";
import { auditDetailsCreate } from "../services/audit";
import { ExpandedMember } from "../../types/organization";

const CREATE_AUTOGENERATED_METRICS_JOB_NAME = "createAutoGeneratedMetrics";

type CreateAutoGeneratedMetricsJob = Job<{
  organization: string;
  datasourceId: string;
  metricsToCreate: Pick<
    MetricInterface,
    | "name"
    | "type"
    | "sql"
    | "id"
    | "organization"
    | "datasource"
    | "dateCreated"
    | "dateUpdated"
  >[];
  user: ExpandedMember;
}>;

let agenda: Agenda;
export default function (ag: Agenda) {
  agenda = ag;

  agenda.define(
    CREATE_AUTOGENERATED_METRICS_JOB_NAME,
    async (job: CreateAutoGeneratedMetricsJob) => {
      const {
        datasourceId,
        organization,
        metricsToCreate,
        user,
      } = job.attrs.data;

      try {
        const datasource = await getDataSourceById(datasourceId, organization);

        if (!datasource) throw new Error("No datasource");

        const schemaFormat = datasource.settings.schemaFormat || "custom";

        if (schemaFormat === "custom")
          throw new Error(
            `Unable to automatically generate metrics for a custom schema format.`
          );

        const integration = getSourceIntegrationObject(datasource);

        if (!integration.getSourceProperties().supportsAutoGeneratedMetrics)
          throw new Error(
            "Auto generated metrics not supported for this data source"
          );

        const metrics: Pick<
          MetricInterface,
          | "name"
          | "type"
          | "sql"
          | "id"
          | "organization"
          | "datasource"
          | "dateCreated"
          | "dateUpdated"
        >[] = [];

        metricsToCreate.forEach((metric) => {
          metric.id = uniqid("met_");
          metric.organization = organization;
          metric.datasource = datasourceId;
          metric.dateCreated = new Date();
          metric.dateUpdated = new Date();
          metrics.push(metric);
        });

        await insertMetrics(metrics);

        for (const metric of metrics) {
          await insertAudit({
            event: "metric.create",
            entity: {
              object: "metric",
              id: metric.id,
            },
            organization,
            dateCreated: metric.dateCreated ? metric.dateCreated : undefined,
            details: auditDetailsCreate(metric),
            user: {
              id: user.id,
              email: user.email,
              name: user.name,
            },
          });
        }
      } catch (e) {
        logger.error(
          e,
          "Failed to generate automatic metrics. Reason: " + e.message
        );
      }
    }
  );
}

export async function queueCreateAutoGeneratedMetrics(
  datasourceId: string,
  organization: string,
  metricsToCreate: { name: string; type: MetricType; sql: string }[],
  user: ExpandedMember | undefined
) {
  if (!datasourceId || !organization || !metricsToCreate || !user) return;

  const job = agenda.create(CREATE_AUTOGENERATED_METRICS_JOB_NAME, {
    organization,
    datasourceId,
    metricsToCreate,
    user,
  }) as CreateAutoGeneratedMetricsJob;
  job.unique({ datasourceId, organization, metricsToCreate });
  job.schedule(new Date());
  await job.save();
}
