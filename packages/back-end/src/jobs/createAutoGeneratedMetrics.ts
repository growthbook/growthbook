/* eslint-disable no-console */
import Agenda, { Job } from "agenda";
import uniqid from "uniqid";
import { getDataSourceById } from "back-end/src/models/DataSourceModel";
import { insertMetrics } from "back-end/src/models/MetricModel";
import { InsertMetricProps } from "back-end/types/metric";
import { getSourceIntegrationObject } from "back-end/src/services/datasource";
import { logger } from "back-end/src/util/logger";
import { insertAudit } from "back-end/src/models/AuditModel";
import { auditDetailsCreate } from "back-end/src/services/audit";
import { ExpandedMember } from "back-end/types/organization";
import { AuditUserLoggedIn } from "back-end/types/audit";
import { getContextForAgendaJobByOrgId } from "back-end/src/services/organizations";
import { trackJob } from "back-end/src/services/otel";
import { AutoMetricToCreate } from "back-end/src/types/Integration";

const CREATE_AUTOGENERATED_METRICS_JOB_NAME = "createAutoGeneratedMetrics";

type CreateAutoGeneratedMetricsJob = Job<{
  organizationId: string;
  datasourceId: string;
  metricsToCreate: AutoMetricToCreate[];
  user: Omit<
    ExpandedMember,
    "role" | "verified" | "limitAccessByEnvironment" | "environments"
  >;
}>;

const createAutoGeneratedMetrics = trackJob(
  CREATE_AUTOGENERATED_METRICS_JOB_NAME,
  async (job: CreateAutoGeneratedMetricsJob) => {
    const {
      datasourceId,
      organizationId,
      metricsToCreate,
      user,
    } = job.attrs.data;

    const context = await getContextForAgendaJobByOrgId(organizationId);

    try {
      const datasource = await getDataSourceById(context, datasourceId);

      if (!datasource) throw new Error("No datasource");

      const schemaFormat = datasource.settings.schemaFormat || "custom";

      if (schemaFormat === "custom")
        throw new Error(
          `Unable to automatically generate metrics for a custom schema format.`
        );

      const integration = getSourceIntegrationObject(context, datasource);

      if (!integration.getSourceProperties().supportsAutoGeneratedMetrics)
        throw new Error(
          "Auto generated metrics not supported for this data source"
        );

      const metrics: InsertMetricProps[] = [];

      metricsToCreate.forEach((metric) => {
        metrics.push({
          id: uniqid("met_"),
          organization: organizationId,
          datasource: datasourceId,
          dateCreated: new Date(),
          dateUpdated: new Date(),
          name: metric.name,
          type: metric.type,
          sql: metric.sql,
          userIdTypes: metric.userIdTypes,
        });
      });

      await insertMetrics(metrics);

      for (const metric of metrics) {
        await insertAudit({
          event: "metric.autocreate",
          entity: {
            object: "metric",
            id: metric.id,
          },
          organization: organizationId,
          dateCreated: metric.dateCreated ? metric.dateCreated : new Date(),
          details: auditDetailsCreate(metric),
          user,
        });
      }
    } catch (e) {
      logger.error(
        e,
        "Failed to generate automatic metrics. Reason: " + e.message
      );
    }
  }
);

let agenda: Agenda;
export default function (ag: Agenda) {
  agenda = ag;
  agenda.define(
    CREATE_AUTOGENERATED_METRICS_JOB_NAME,
    createAutoGeneratedMetrics
  );
}

export async function queueCreateAutoGeneratedMetrics(
  datasourceId: string,
  organizationId: string,
  metricsToCreate: AutoMetricToCreate[],
  user: AuditUserLoggedIn
) {
  if (!datasourceId || !organizationId || !metricsToCreate || !user) return;

  const job = agenda.create(CREATE_AUTOGENERATED_METRICS_JOB_NAME, {
    organizationId,
    datasourceId,
    metricsToCreate,
    user,
  }) as CreateAutoGeneratedMetricsJob;
  job.unique({ datasourceId, organizationId, metricsToCreate });
  job.schedule(new Date());
  await job.save();
}
