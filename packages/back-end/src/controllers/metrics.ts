import { Response } from "express";
import { isFactMetricId } from "shared/experiments";
import { daysBetween } from "shared/dates";
import { AuthRequest } from "back-end/src/types/AuthRequest";
import {
  _getSnapshots,
  createMetric,
  refreshMetric,
} from "back-end/src/services/experiments";
import { MetricInterface } from "back-end/types/metric";
import { ExperimentWithSnapshot } from "back-end/types/experiment-snapshot";
import {
  getExperimentsByMetric,
  getExperimentsUsingMetric,
} from "back-end/src/models/ExperimentModel";
import { getContextFromReq } from "back-end/src/services/organizations";
import {
  deleteMetricById,
  getMetricsByOrganization,
  getMetricById,
  updateMetric,
  getMetricsByDatasource,
  getMetricsByIds,
} from "back-end/src/models/MetricModel";
import { IdeaInterface } from "back-end/types/idea";

import { getDataSourceById } from "back-end/src/models/DataSourceModel";
import { getIdeasByQuery } from "back-end/src/services/ideas";
import { ImpactEstimateModel } from "back-end/src/models/ImpactEstimateModel";
import {
  auditDetailsCreate,
  auditDetailsUpdate,
  auditDetailsDelete,
} from "back-end/src/services/audit";
import { EventUserForResponseLocals } from "back-end/src/events/event-types";
import { queueCreateAutoGeneratedMetrics } from "back-end/src/jobs/createAutoGeneratedMetrics";
import { getIntegrationFromDatasourceId } from "back-end/src/services/datasource";
import {
  AutoMetricToCreate,
  AutoMetricTrackedEvent,
} from "back-end/src/types/Integration";
import { LegacyMetricAnalysisQueryRunner } from "back-end/src/queryRunners/LegacyMetricAnalysisQueryRunner";
import { getUserById } from "back-end/src/models/UserModel";
import { AuditUserLoggedIn } from "back-end/types/audit";
import { ExperimentInterfaceStringDates } from "back-end/types/experiment";
import { MetricAnalysisInterface } from "back-end/types/metric-analysis";

/**
 * Fields on a metric that we allow users to update. Excluded fields are
 * those that are set by asynchronous analysis jobs that run internally.
 */
export const UPDATEABLE_FIELDS: (keyof MetricInterface)[] = [
  "name",
  "description",
  "owner",
  "segment",
  "type",
  "inverse",
  "ignoreNulls",
  "denominator",
  "cappingSettings",
  "windowSettings",
  "priorSettings",
  "sql",
  "aggregation",
  "queryFormat",
  "status",
  "tags",
  "projects",
  "winRisk",
  "loseRisk",
  "maxPercentChange",
  "minPercentChange",
  "minSampleSize",
  "targetMDE",
  "regressionAdjustmentOverride",
  "regressionAdjustmentEnabled",
  "regressionAdjustmentDays",
  "conditions",
  "dateUpdated",
  "table",
  "column",
  "userIdColumns",
  "userIdTypes",
  "timestampColumn",
  "templateVariables",
];

export async function deleteMetric(
  req: AuthRequest<null, { id: string }>,
  res: Response<unknown, EventUserForResponseLocals>
) {
  const context = getContextFromReq(req);
  const { id } = req.params;

  const metric = await getMetricById(context, id);

  if (!metric) {
    res.status(403).json({
      status: 404,
      message: "Metric not found",
    });
    return;
  }

  if (!context.permissions.canDeleteMetric(metric)) {
    context.permissions.throwPermissionError();
  }

  // now remove the metric itself:
  await deleteMetricById(context, metric);

  await req.audit({
    event: "metric.delete",
    entity: {
      object: "metric",
      id: metric.id,
    },
    details: auditDetailsDelete(metric),
  });

  res.status(200).json({
    status: 200,
  });
}

export async function deleteMetrics(
  req: AuthRequest<{ ids: string[] }, null, { delete: boolean }>,
  res: Response<unknown, EventAuditUserForResponseLocals>
) {
  const context = getContextFromReq(req);
  const ids = req.body.ids;

  const metrics = await getMetricsByIds(context, ids);

  const metricMap = new Map(metrics.map((m) => [m.id, m]));

  const notFoundIds = ids.filter((id) => !metricMap.has(id));

  if (notFoundIds.length > 0) {
    res.status(403).json({
      status: 404,
      message: "Could not find metrics with IDs: " + notFoundIds.join(", "),
    });
    return;
  }

  if (req.query.delete) {
    for (const metric of metrics) {
      if (!context.permissions.canDeleteMetric(metric)) {
        context.permissions.throwPermissionError();
      }
    }
  } else {
    for (const metric of metrics) {
      if (!context.permissions.canUpdateMetric(metric, {})) {
        context.permissions.throwPermissionError();
      }
    }
  }

  if (req.query.delete) {
    for (const metric of metrics) {
      await deleteMetricById(context, metric);
      await req.audit({
        event: "metric.delete",
        entity: {
          object: "metric",
          id: metric.id,
        },
        details: auditDetailsDelete(metric),
      });
    }
  } else {
    for (const metric of metrics) {
      await updateMetric(context, metric, { status: "archived" });
      metric.status = "archived";
      await req.audit({
        event: "metric.update",
        entity: {
          object: "metric",
          id: metric.id,
        },
        details: auditDetailsUpdate(metric, metric),
      });
    }
  }

  res.status(200).json({
    status: 200,
    modifiedIds: ids,
  });
}

export async function getMetrics(req: AuthRequest, res: Response) {
  const context = getContextFromReq(req);
  const metrics = await getMetricsByOrganization(context);
  res.status(200).json({
    status: 200,
    metrics,
  });
}

export async function getMetricUsage(
  req: AuthRequest<null, { id: string }>,
  res: Response
) {
  const { id } = req.params;
  const context = getContextFromReq(req);
  const { org } = context;
  const metric = await getMetricById(context, id);

  if (!metric) {
    res.status(403).json({
      status: 404,
      message: "Metric not found",
    });
    return;
  }

  // metrics are used in a few places:

  // Ideas (impact estimate)
  const estimates = await ImpactEstimateModel.find({
    metric: metric.id,
    organization: org.id,
  });
  const ideas: IdeaInterface[] = [];
  if (estimates && estimates.length > 0) {
    await Promise.all(
      estimates.map(async (es) => {
        const idea = await getIdeasByQuery({
          organization: org.id,
          "estimateParams.estimate": es.id,
        });
        if (idea && idea[0]) {
          ideas.push(idea[0]);
        }
      })
    );
  }

  // Experiments
  const experiments = await getExperimentsByMetric(context, metric.id);

  res.status(200).json({
    ideas,
    experiments,
    status: 200,
  });
}

export async function cancelLegacyMetricAnalysis(
  req: AuthRequest<null, { id: string }>,
  res: Response
) {
  const context = getContextFromReq(req);
  const { id } = req.params;
  const metric = await getMetricById(context, id, true);
  if (!metric) {
    throw new Error("Could not cancel query");
  }

  const integration = await getIntegrationFromDatasourceId(
    context,
    metric.datasource
  );

  const queryRunner = new LegacyMetricAnalysisQueryRunner(
    context,
    metric,
    integration
  );
  await queryRunner.cancelQueries();

  res.status(200).json({
    status: 200,
  });
}

export async function postLegacyMetricAnalysis(
  req: AuthRequest<null, { id: string }>,
  res: Response
) {
  const context = getContextFromReq(req);
  const { id } = req.params;

  const metric = await getMetricById(context, id, true);

  if (!metric) {
    return res.status(404).json({
      status: 404,
      message: "Metric not found",
    });
  }

  try {
    await refreshMetric(
      context,
      metric,
      req.organization?.settings?.metricAnalysisDays
    );

    res.status(200).json({
      status: 200,
    });

    await req.audit({
      event: "metric.analysis",
      entity: {
        object: "metric",
        id: metric.id,
      },
    });
  } catch (e) {
    return res.status(400).json({
      status: 400,
      message: e.message,
    });
  }
}
export async function getMetric(
  req: AuthRequest<null, { id: string }>,
  res: Response
) {
  const context = getContextFromReq(req);
  const { id } = req.params;

  const metric = await getMetricById(context, id, true);

  if (!metric) {
    return res.status(404).json({
      status: 404,
      message: "Metric not found",
    });
  }

  res.status(200).json({
    status: 200,
    metric,
  });
}

export async function getMetricsFromTrackedEvents(
  req: AuthRequest<{ schema: string }, { datasourceId: string }>,
  res: Response
) {
  const context = getContextFromReq(req);
  const { schema } = req.body;
  const { datasourceId } = req.params;

  const integration = await getIntegrationFromDatasourceId(
    context,
    datasourceId
  );

  // When we create auto metrics, they inherit the data source's projects, so we check if the user
  // has permission to createMetrics for the data source's projects
  if (
    !context.permissions.canCreateMetric({
      projects: integration.datasource.projects,
    })
  ) {
    context.permissions.throwPermissionError();
  }

  if (!context.permissions.canRunSchemaQueries(integration.datasource)) {
    context.permissions.throwPermissionError();
  }

  try {
    if (
      !integration.getAutoMetricsToCreate ||
      !integration.datasource.settings.schemaFormat ||
      !integration.getSourceProperties().supportsAutoGeneratedMetrics
    ) {
      throw new Error("Datasource does not support auto-metrics");
    }

    const existingMetrics = await getMetricsByDatasource(
      context,
      integration.datasource.id
    );

    const trackedEvents: AutoMetricTrackedEvent[] =
      await integration.getAutoMetricsToCreate(existingMetrics, schema);

    return res.status(200).json({
      status: 200,
      trackedEvents,
    });
  } catch (e) {
    res.status(200).json({
      status: 200,
      trackedEvents: [],
      message: e.message,
    });
    return;
  }
}

export async function postAutoGeneratedMetrics(
  req: AuthRequest<{
    datasourceId: string;
    projects?: string[];
    metricsToCreate?: AutoMetricToCreate[];
  }>,
  res: Response
) {
  const context = getContextFromReq(req);
  const { org } = context;

  const userId = req.userId;

  if (!userId) {
    res.status(403).json({
      status: 403,
      message: "User not found",
    });
    return;
  }

  const user = await getUserById(userId);

  if (!user) {
    res.status(403).json({
      status: 403,
      message: "User not found",
    });
    return;
  }

  const userObj: AuditUserLoggedIn = {
    id: user.id,
    email: user.email,
    name: user.name || "",
  };

  const { datasourceId, metricsToCreate, projects } = req.body;

  if (!context.permissions.canCreateMetric({ projects })) {
    context.permissions.throwPermissionError();
  }

  const datasourceObj = await getDataSourceById(context, datasourceId);
  if (!datasourceObj) {
    res.status(403).json({
      status: 403,
      message: "Invalid data source: " + datasourceId,
    });
    return;
  }

  if (metricsToCreate?.length) {
    await queueCreateAutoGeneratedMetrics(
      datasourceId,
      org.id,
      metricsToCreate,
      userObj
    );
  }

  res.status(200).json({
    status: 200,
  });
}
export async function postMetrics(
  req: AuthRequest<Partial<MetricInterface>>,
  res: Response
) {
  const context = getContextFromReq(req);
  const { org, userName } = context;

  const {
    name,
    description,
    type,
    table,
    column,
    inverse,
    ignoreNulls,
    denominator,
    cappingSettings,
    windowSettings,
    priorSettings,
    sql,
    aggregation,
    queryFormat,
    segment,
    tags,
    projects,
    winRisk,
    loseRisk,
    maxPercentChange,
    minPercentChange,
    minSampleSize,
    targetMDE,
    regressionAdjustmentOverride,
    regressionAdjustmentEnabled,
    regressionAdjustmentDays,
    conditions,
    datasource,
    timestampColumn,
    userIdColumns,
    userIdTypes,
    templateVariables,
  } = req.body;

  if (!context.permissions.canCreateMetric({ projects })) {
    context.permissions.throwPermissionError();
  }

  if (datasource) {
    const datasourceObj = await getDataSourceById(context, datasource);
    if (!datasourceObj) {
      res.status(403).json({
        status: 403,
        message: "Invalid data source: " + datasource,
      });
      return;
    }
  }

  const metric = await createMetric({
    organization: org.id,
    owner: userName,
    datasource,
    name,
    description,
    type,
    segment,
    table,
    column,
    inverse,
    ignoreNulls,
    denominator,
    cappingSettings,
    windowSettings,
    priorSettings,
    userIdTypes,
    sql,
    aggregation,
    queryFormat,
    status: "active",
    userIdColumns,
    timestampColumn,
    conditions,
    tags,
    projects,
    winRisk,
    loseRisk,
    maxPercentChange,
    minPercentChange,
    minSampleSize,
    targetMDE,
    regressionAdjustmentOverride,
    regressionAdjustmentEnabled,
    regressionAdjustmentDays,
    templateVariables,
  });

  res.status(200).json({
    status: 200,
    metric,
  });

  await req.audit({
    event: "metric.create",
    entity: {
      object: "metric",
      id: metric.id,
    },
    details: auditDetailsCreate(metric),
  });
}

export async function putMetric(
  req: AuthRequest<Partial<MetricInterface>, { id: string }>,
  res: Response
) {
  const context = getContextFromReq(req);
  const { id } = req.params;
  const metric = await getMetricById(context, id);
  if (!metric) {
    throw new Error("Could not find metric");
  }

  const updates: Partial<MetricInterface> = {};

  UPDATEABLE_FIELDS.forEach((k) => {
    if (k in req.body) {
      // eslint-disable-next-line
      (updates as any)[k] = req.body[k];
    }
  });

  if (!context.permissions.canUpdateMetric(metric, updates)) {
    context.permissions.throwPermissionError();
  }

  await updateMetric(context, metric, updates);

  res.status(200).json({
    status: 200,
  });

  await req.audit({
    event: "metric.update",
    entity: {
      object: "metric",
      id: metric.id,
    },
    details: auditDetailsUpdate(metric, {
      ...metric,
      ...updates,
    }),
  });
}

export const getMetricExperimentResults = async (
  req: AuthRequest<unknown, { id: string }>,
  res: Response<{ status: 200; data: ExperimentWithSnapshot[] }>
) => {
  const context = getContextFromReq(req);

  const experiments = await getExperimentsUsingMetric(
    context,
    req.params.id,
    500
  );

  const snapshots = await _getSnapshots(context, experiments);

  // TODO simplify data for front-end?
  const data = experiments.map((e) => ({
    ...e,
    dateCreated: e.dateCreated.toISOString(),
    dateUpdated: e.dateUpdated.toISOString(),
    phases: e.phases.map((p) => ({
      ...p,
      dateStarted: p.dateStarted.toISOString(),
      dateEnded: p.dateEnded?.toISOString(),
    })),
    snapshot: snapshots.find((s) => s.experiment === e.id),
  }));

  res.status(200).json({
    status: 200,
    data,
  });
};

export const getMetricNorthstarData = async (
  req: AuthRequest<unknown, { id: string }>,
  res: Response<{
    status: 200;
    data: {
      experiments: ExperimentInterfaceStringDates[];
      analysis: MetricAnalysisInterface | null;
      metric: MetricInterface | null;
    };
  }>
) => {
  // get metric analysis and latest experiments
  const context = getContextFromReq(req);

  const experiments = await getExperimentsUsingMetric(
    context,
    req.params.id,
    100
  );

  // get analysis
  let analysis: MetricAnalysisInterface | null = null;
  let metric: MetricInterface | null = null;
  if (isFactMetricId(req.params.id)) {
    analysis = await context.models.metricAnalysis.findLatestByMetric(
      req.params.id,
      true
    );
  } else {
    metric = await getMetricById(context, req.params.id, true);
    if (metric && metric.analysis && metric.analysis.dates.length) {
      // do my best to take legacy analysis and port it to new
      const startDate = metric.analysis.dates[0].d;
      const endDate = metric.analysis.dates[metric.analysis.dates.length - 1].d;
      analysis = {
        id: "spoofed_metan",
        organization: metric.organization,
        metric: metric.id,
        error: metric.analysisError,
        dateCreated: metric.analysis.createdAt,
        dateUpdated: metric.analysis.createdAt,
        runStarted: metric.runStarted,
        status: metric.analysisError ? "failed" : "succeeded",
        result: {
          units: metric.analysis.count ?? 0,
          mean: metric.analysis.average,
          stddev: metric.analysis.stddev,
          dates: metric.analysis.dates.map((d) => ({
            date: d.d,
            units: d.c ?? 0,
            mean: d.v,
            stddev: d.s,
          })),
        },
        settings: {
          userIdType: metric.userIdTypes?.[0] ?? "user_id", // reasonable guess
          startDate: startDate,
          endDate: endDate,
          lookbackDays: daysBetween(startDate, endDate),
          populationType: metric.segment ? "segment" : "metric",
          populationId: metric.segment ?? null,
        },
        queries: metric.queries,
      };
    }
  }

  const experimentsStringDates = experiments.map((e) => ({
    ...e,
    dateCreated: e.dateCreated.toISOString(),
    dateUpdated: e.dateUpdated.toISOString(),
    phases: e.phases.map((p) => ({
      ...p,
      dateStarted: p.dateStarted.toISOString(),
      dateEnded: p.dateEnded?.toISOString(),
    })),
  }));

  res.status(200).json({
    status: 200,
    data: {
      experiments: experimentsStringDates,
      analysis,
      metric,
    },
  });
};
