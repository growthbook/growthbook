import { z } from "zod";
import { baseSchema } from "back-end/src/models/BaseModel";
import { getMetricMap } from "back-end/src/models/MetricModel";
import { experimentAnalysisSummary } from "back-end/src/validators/experiments";
import { ApiReqContext } from "back-end/types/api";
import { ReqContext } from "back-end/types/organization";

export const safeRolloutStatusArray = [
  "running",
  "rolled-back",
  "released",
  "stopped",
] as const;
export type SafeRolloutStatus = typeof safeRolloutStatusArray[number];

export const MaxDuration = z.object({
  amount: z.number(),
  unit: z.enum(["weeks", "days", "hours", "minutes"]),
});
// NB: These are the fields that the user submit, and the rest of the interface
// is generated by us based on this information + feature & rule definition.
const rampUpSchedule = z.object({
  enabled: z.boolean(),
  step: z.number(),
  steps: z.array(
    z.object({
      percent: z.number(),
      dateRampedUp: z.date().optional(),
    })
  ),
  nextUpdate: z.date().optional(),
  lastUpdate: z.date().optional(),
  rampUpCompleted: z.boolean(),
});
export type RampUpSchedule = z.infer<typeof rampUpSchedule>;

export const createSafeRolloutValidator = z.object({
  datasourceId: z.string(),
  exposureQueryId: z.string(),
  guardrailMetricIds: z.array(z.string()),
  maxDuration: MaxDuration,
  autoRollback: z.boolean(),
  rampUpSchedule: rampUpSchedule.partial().optional(),
});
export type CreateSafeRolloutInterface = z.infer<
  typeof createSafeRolloutValidator
>;

const safeRolloutNotification = [
  "srm",
  "multipleExposures",
  "ship",
  "rollback",
] as const;
export type SafeRolloutNotification = typeof safeRolloutNotification[number];

const safeRollout = createSafeRolloutValidator.extend({
  // Refs
  featureId: z.string(),
  environment: z.string(),

  // Managed fields
  status: z.enum(safeRolloutStatusArray),
  autoSnapshots: z.boolean().default(true),
  startedAt: z.date().optional(),
  lastSnapshotAttempt: z.date().optional(),
  nextSnapshotAttempt: z.date().optional(),
  analysisSummary: experimentAnalysisSummary.optional(),
  pastNotifications: z.array(z.enum(safeRolloutNotification)).optional(),
  rampUpSchedule: rampUpSchedule,
});
export const safeRolloutValidator = baseSchema
  .extend(safeRollout.shape)
  .strict();
export type SafeRolloutInterface = z.infer<typeof safeRolloutValidator>;

export async function validateCreateSafeRolloutFields(
  safeRolloutFields: Partial<CreateSafeRolloutInterface> | undefined,
  context: ReqContext | ApiReqContext
): Promise<CreateSafeRolloutInterface> {
  // TODO: How to use Zod validator here and provide a good error message to the user?
  if (!safeRolloutFields) {
    throw new Error("Safe Rollout fields must be set");
  }
  if (
    safeRolloutFields?.maxDuration?.amount === undefined ||
    safeRolloutFields?.maxDuration?.amount < 1
  ) {
    throw new Error("Time to monitor must be at least 1 day");
  }
  if (safeRolloutFields.maxDuration.unit === undefined) {
    throw new Error("Time to monitor must be specified for safe rollouts");
  }
  if (safeRolloutFields.exposureQueryId === undefined) {
    throw new Error("Exposure query must be specified for safe rollouts");
  }
  if (safeRolloutFields.datasourceId === undefined) {
    throw new Error("Datasource must be specified for safe rollouts");
  }
  if (
    safeRolloutFields.guardrailMetricIds === undefined ||
    safeRolloutFields.guardrailMetricIds.length === 0
  ) {
    throw new Error("Please select at least 1 guardrail metric");
  }

  const metricIds = safeRolloutFields.guardrailMetricIds;
  const datasourceId = safeRolloutFields.datasourceId;
  if (metricIds.length) {
    const map = await getMetricMap(context);
    for (let i = 0; i < metricIds.length; i++) {
      const metric = map.get(metricIds[i]);
      if (metric) {
        if (datasourceId && metric.datasource !== datasourceId) {
          throw new Error(
            "Metrics must belong to the same datasource as the safe rollout: " +
              metricIds[i]
          );
        }
      } else {
        // check to see if this metric is actually a metric group
        const metricGroup = await context.models.metricGroups.getById(
          metricIds[i]
        );
        if (metricGroup) {
          // Make sure it is tied to the same datasource as the experiment
          if (datasourceId && metricGroup.datasource !== datasourceId) {
            throw new Error(
              "Metrics must be tied to the same datasource as the safe rollout: " +
                metricIds[i]
            );
          }
        } else {
          // new metric that's not recognized...
          throw new Error("Invalid metric specified: " + metricIds[i]);
        }
      }
    }
  }

  return createSafeRolloutValidator.strip().parse(safeRolloutFields);
}
