/* eslint-disable */
/**
* This file was auto-generated. DO NOT MODIFY DIRECTLY
* Instead, modify the source OpenAPI schema in back-end/src/api/openapi
* and run `yarn generate-api-types` to re-generate this file.
*/
import { z } from "zod";

export const apiPaginationFieldsValidator = z.object({ "limit": z.coerce.number().int(), "offset": z.coerce.number().int(), "count": z.coerce.number().int(), "total": z.coerce.number().int(), "hasMore": z.boolean(), "nextOffset": z.union([z.coerce.number().int(), z.null()]) }).strict()

export const apiDimensionValidator = z.object({ "id": z.string(), "dateCreated": z.string(), "dateUpdated": z.string(), "owner": z.string(), "datasourceId": z.string(), "identifierType": z.string(), "name": z.string(), "description": z.string().optional(), "query": z.string(), "managedBy": z.enum(["","api","config"]).describe("Where this dimension must be managed from. If not set (empty string), it can be managed from anywhere.").optional() }).strict()

export const apiMetricValidator = z.object({ "id": z.string(), "managedBy": z.enum(["","api","config","admin"]).describe("Where this metric must be managed from. If not set (empty string), it can be managed from anywhere."), "dateCreated": z.string(), "dateUpdated": z.string(), "owner": z.string(), "datasourceId": z.string(), "name": z.string(), "description": z.string(), "type": z.enum(["binomial","count","duration","revenue"]), "tags": z.array(z.string()), "projects": z.array(z.string()), "archived": z.boolean(), "behavior": z.object({ "goal": z.enum(["increase","decrease"]), "cappingSettings": z.object({ "type": z.enum(["none","absolute","percentile"]), "value": z.coerce.number().describe("When type is absolute, this is the absolute value. When type is percentile, this is the percentile value (from 0.0 to 1.0).").optional(), "ignoreZeros": z.boolean().describe("If true and capping is `percentile`, zeros will be ignored when calculating the percentile.").optional() }).describe("Controls how outliers are handled").optional(), "cap": z.coerce.number().optional(), "capping": z.enum(["absolute","percentile"]).nullable().optional(), "capValue": z.coerce.number().optional(), "windowSettings": z.object({ "type": z.enum(["none","conversion","lookback"]), "delayValue": z.coerce.number().describe("Wait this long after experiment exposure before counting conversions").optional(), "delayUnit": z.enum(["minutes","hours","days","weeks"]).optional(), "windowValue": z.coerce.number().optional(), "windowUnit": z.enum(["minutes","hours","days","weeks"]).optional() }).describe("Controls the conversion window for the metric"), "priorSettings": z.object({ "override": z.boolean().describe("If false, the organization default settings will be used instead of the other settings in this object"), "proper": z.boolean().describe("If true, the `mean` and `stddev` will be used, otherwise we will use an improper flat prior."), "mean": z.coerce.number().describe("The mean of the prior distribution of relative effects in proportion terms (e.g. 0.01 is 1%)"), "stddev": z.coerce.number().describe("Must be > 0. The standard deviation of the prior distribution of relative effects in proportion terms.") }).describe("Controls the bayesian prior for the metric.").optional(), "conversionWindowStart": z.coerce.number().optional(), "conversionWindowEnd": z.coerce.number().optional(), "riskThresholdSuccess": z.coerce.number(), "riskThresholdDanger": z.coerce.number(), "minPercentChange": z.coerce.number(), "maxPercentChange": z.coerce.number(), "minSampleSize": z.coerce.number(), "targetMDE": z.coerce.number() }), "sql": z.object({ "identifierTypes": z.array(z.string()), "conversionSQL": z.string(), "userAggregationSQL": z.string(), "denominatorMetricId": z.string() }).optional(), "sqlBuilder": z.object({ "identifierTypeColumns": z.array(z.object({ "identifierType": z.string(), "columnName": z.string() })), "tableName": z.string(), "valueColumnName": z.string(), "timestampColumnName": z.string(), "conditions": z.array(z.object({ "column": z.string(), "operator": z.string(), "value": z.string() })) }).optional(), "mixpanel": z.object({ "eventName": z.string(), "eventValue": z.string(), "userAggregation": z.string(), "conditions": z.array(z.object({ "property": z.string(), "operator": z.string(), "value": z.string() })) }).optional() }).strict()

export const apiProjectValidator = z.object({ "id": z.string(), "name": z.string(), "publicId": z.string().optional(), "dateCreated": z.string(), "dateUpdated": z.string(), "description": z.string().optional(), "settings": z.object({ "statsEngine": z.string().optional() }).optional() }).strict()

export const apiEnvironmentValidator = z.object({ "id": z.string(), "description": z.string(), "toggleOnList": z.boolean(), "defaultState": z.boolean(), "projects": z.array(z.string()), "parent": z.string().optional() }).strict()

export const apiAttributeValidator = z.object({ "property": z.string(), "datatype": z.enum(["boolean","string","number","secureString","enum","string[]","number[]","secureString[]"]), "description": z.string().optional(), "hashAttribute": z.boolean().optional(), "archived": z.boolean().optional(), "enum": z.string().optional(), "format": z.enum(["","version","date","isoCountryCode"]).optional(), "projects": z.array(z.string()).optional() }).strict()

export const apiSegmentValidator = z.object({ "id": z.string(), "owner": z.string(), "datasourceId": z.string(), "identifierType": z.string(), "name": z.string(), "description": z.string().optional(), "query": z.string().optional(), "dateCreated": z.string(), "dateUpdated": z.string(), "managedBy": z.enum(["","api","config"]).describe("Where this segment must be managed from. If not set (empty string), it can be managed from anywhere.").optional(), "type": z.enum(["SQL","FACT"]).optional(), "factTableId": z.string().optional(), "filters": z.array(z.string()).optional(), "projects": z.array(z.string()).optional() }).strict()

export const apiScheduleRuleValidator = z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.").strict()

export const apiFeatureValidator = z.object({ "id": z.string(), "dateCreated": z.string(), "dateUpdated": z.string(), "archived": z.boolean(), "description": z.string(), "owner": z.string(), "project": z.string(), "valueType": z.enum(["boolean","string","number","json"]), "defaultValue": z.string(), "tags": z.array(z.string()), "environments": z.record(z.string(), z.object({ "enabled": z.boolean(), "defaultValue": z.string(), "rules": z.array(z.union([z.object({ "description": z.string(), "condition": z.string(), "savedGroupTargeting": z.array(z.object({ "matchType": z.enum(["all","any","none"]), "savedGroups": z.array(z.string()) })).optional(), "prerequisites": z.array(z.object({ "id": z.string().describe("Feature ID"), "condition": z.string() })).optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional(), "id": z.string(), "enabled": z.boolean(), "type": z.literal("force"), "value": z.string() }), z.object({ "description": z.string(), "condition": z.string(), "savedGroupTargeting": z.array(z.object({ "matchType": z.enum(["all","any","none"]), "savedGroups": z.array(z.string()) })).optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional(), "id": z.string(), "enabled": z.boolean(), "type": z.literal("rollout"), "value": z.string(), "coverage": z.coerce.number(), "hashAttribute": z.string() }), z.object({ "description": z.string(), "condition": z.string(), "id": z.string(), "enabled": z.boolean(), "type": z.literal("experiment"), "trackingKey": z.string().optional(), "hashAttribute": z.string().optional(), "fallbackAttribute": z.string().optional(), "disableStickyBucketing": z.boolean().optional(), "bucketVersion": z.coerce.number().optional(), "minBucketVersion": z.coerce.number().optional(), "namespace": z.object({ "enabled": z.boolean(), "name": z.string(), "range": z.array(z.coerce.number()).min(2).max(2) }).optional(), "coverage": z.coerce.number().optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional(), "value": z.array(z.object({ "value": z.string(), "weight": z.coerce.number(), "name": z.string().optional() })).optional() }), z.object({ "description": z.string(), "id": z.string(), "enabled": z.boolean(), "type": z.literal("experiment-ref"), "condition": z.string().optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional(), "variations": z.array(z.object({ "value": z.string(), "variationId": z.string() })), "experimentId": z.string() }), z.object({ "condition": z.string(), "savedGroupTargeting": z.array(z.object({ "matchType": z.enum(["all","any","none"]), "savedGroups": z.array(z.string()) })).optional(), "prerequisites": z.array(z.object({ "id": z.string().describe("Feature ID"), "condition": z.string() })).optional(), "id": z.string(), "trackingKey": z.string().optional(), "enabled": z.boolean(), "type": z.literal("safe-rollout"), "controlValue": z.string(), "variationValue": z.string(), "seed": z.string().optional(), "hashAttribute": z.string().optional(), "safeRolloutId": z.string().optional(), "status": z.enum(["running","released","rolled-back","stopped"]).optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional() })])), "definition": z.string().describe("A JSON stringified [FeatureDefinition](#tag/FeatureDefinition_model)").optional(), "draft": z.object({ "enabled": z.boolean(), "defaultValue": z.string(), "rules": z.array(z.union([z.object({ "description": z.string(), "condition": z.string(), "savedGroupTargeting": z.array(z.object({ "matchType": z.enum(["all","any","none"]), "savedGroups": z.array(z.string()) })).optional(), "prerequisites": z.array(z.object({ "id": z.string().describe("Feature ID"), "condition": z.string() })).optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional(), "id": z.string(), "enabled": z.boolean(), "type": z.literal("force"), "value": z.string() }), z.object({ "description": z.string(), "condition": z.string(), "savedGroupTargeting": z.array(z.object({ "matchType": z.enum(["all","any","none"]), "savedGroups": z.array(z.string()) })).optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional(), "id": z.string(), "enabled": z.boolean(), "type": z.literal("rollout"), "value": z.string(), "coverage": z.coerce.number(), "hashAttribute": z.string() }), z.object({ "description": z.string(), "condition": z.string(), "id": z.string(), "enabled": z.boolean(), "type": z.literal("experiment"), "trackingKey": z.string().optional(), "hashAttribute": z.string().optional(), "fallbackAttribute": z.string().optional(), "disableStickyBucketing": z.boolean().optional(), "bucketVersion": z.coerce.number().optional(), "minBucketVersion": z.coerce.number().optional(), "namespace": z.object({ "enabled": z.boolean(), "name": z.string(), "range": z.array(z.coerce.number()).min(2).max(2) }).optional(), "coverage": z.coerce.number().optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional(), "value": z.array(z.object({ "value": z.string(), "weight": z.coerce.number(), "name": z.string().optional() })).optional() }), z.object({ "description": z.string(), "id": z.string(), "enabled": z.boolean(), "type": z.literal("experiment-ref"), "condition": z.string().optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional(), "variations": z.array(z.object({ "value": z.string(), "variationId": z.string() })), "experimentId": z.string() }), z.object({ "condition": z.string(), "savedGroupTargeting": z.array(z.object({ "matchType": z.enum(["all","any","none"]), "savedGroups": z.array(z.string()) })).optional(), "prerequisites": z.array(z.object({ "id": z.string().describe("Feature ID"), "condition": z.string() })).optional(), "id": z.string(), "trackingKey": z.string().optional(), "enabled": z.boolean(), "type": z.literal("safe-rollout"), "controlValue": z.string(), "variationValue": z.string(), "seed": z.string().optional(), "hashAttribute": z.string().optional(), "safeRolloutId": z.string().optional(), "status": z.enum(["running","released","rolled-back","stopped"]).optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional() })])), "definition": z.string().describe("A JSON stringified [FeatureDefinition](#tag/FeatureDefinition_model)").optional() }).optional() })), "prerequisites": z.array(z.string()).describe("Feature IDs. Each feature must evaluate to `true`").optional(), "revision": z.object({ "version": z.coerce.number().int(), "comment": z.string(), "date": z.string(), "publishedBy": z.string() }), "customFields": z.record(z.string(), z.any()).optional() }).strict()

export const apiFeatureWithRevisionsValidator = z.intersection(z.object({ "id": z.string(), "dateCreated": z.string(), "dateUpdated": z.string(), "archived": z.boolean(), "description": z.string(), "owner": z.string(), "project": z.string(), "valueType": z.enum(["boolean","string","number","json"]), "defaultValue": z.string(), "tags": z.array(z.string()), "environments": z.record(z.string(), z.object({ "enabled": z.boolean(), "defaultValue": z.string(), "rules": z.array(z.union([z.object({ "description": z.string(), "condition": z.string(), "savedGroupTargeting": z.array(z.object({ "matchType": z.enum(["all","any","none"]), "savedGroups": z.array(z.string()) })).optional(), "prerequisites": z.array(z.object({ "id": z.string().describe("Feature ID"), "condition": z.string() })).optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional(), "id": z.string(), "enabled": z.boolean(), "type": z.literal("force"), "value": z.string() }), z.object({ "description": z.string(), "condition": z.string(), "savedGroupTargeting": z.array(z.object({ "matchType": z.enum(["all","any","none"]), "savedGroups": z.array(z.string()) })).optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional(), "id": z.string(), "enabled": z.boolean(), "type": z.literal("rollout"), "value": z.string(), "coverage": z.coerce.number(), "hashAttribute": z.string() }), z.object({ "description": z.string(), "condition": z.string(), "id": z.string(), "enabled": z.boolean(), "type": z.literal("experiment"), "trackingKey": z.string().optional(), "hashAttribute": z.string().optional(), "fallbackAttribute": z.string().optional(), "disableStickyBucketing": z.boolean().optional(), "bucketVersion": z.coerce.number().optional(), "minBucketVersion": z.coerce.number().optional(), "namespace": z.object({ "enabled": z.boolean(), "name": z.string(), "range": z.array(z.coerce.number()).min(2).max(2) }).optional(), "coverage": z.coerce.number().optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional(), "value": z.array(z.object({ "value": z.string(), "weight": z.coerce.number(), "name": z.string().optional() })).optional() }), z.object({ "description": z.string(), "id": z.string(), "enabled": z.boolean(), "type": z.literal("experiment-ref"), "condition": z.string().optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional(), "variations": z.array(z.object({ "value": z.string(), "variationId": z.string() })), "experimentId": z.string() }), z.object({ "condition": z.string(), "savedGroupTargeting": z.array(z.object({ "matchType": z.enum(["all","any","none"]), "savedGroups": z.array(z.string()) })).optional(), "prerequisites": z.array(z.object({ "id": z.string().describe("Feature ID"), "condition": z.string() })).optional(), "id": z.string(), "trackingKey": z.string().optional(), "enabled": z.boolean(), "type": z.literal("safe-rollout"), "controlValue": z.string(), "variationValue": z.string(), "seed": z.string().optional(), "hashAttribute": z.string().optional(), "safeRolloutId": z.string().optional(), "status": z.enum(["running","released","rolled-back","stopped"]).optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional() })])), "definition": z.string().describe("A JSON stringified [FeatureDefinition](#tag/FeatureDefinition_model)").optional(), "draft": z.object({ "enabled": z.boolean(), "defaultValue": z.string(), "rules": z.array(z.union([z.object({ "description": z.string(), "condition": z.string(), "savedGroupTargeting": z.array(z.object({ "matchType": z.enum(["all","any","none"]), "savedGroups": z.array(z.string()) })).optional(), "prerequisites": z.array(z.object({ "id": z.string().describe("Feature ID"), "condition": z.string() })).optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional(), "id": z.string(), "enabled": z.boolean(), "type": z.literal("force"), "value": z.string() }), z.object({ "description": z.string(), "condition": z.string(), "savedGroupTargeting": z.array(z.object({ "matchType": z.enum(["all","any","none"]), "savedGroups": z.array(z.string()) })).optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional(), "id": z.string(), "enabled": z.boolean(), "type": z.literal("rollout"), "value": z.string(), "coverage": z.coerce.number(), "hashAttribute": z.string() }), z.object({ "description": z.string(), "condition": z.string(), "id": z.string(), "enabled": z.boolean(), "type": z.literal("experiment"), "trackingKey": z.string().optional(), "hashAttribute": z.string().optional(), "fallbackAttribute": z.string().optional(), "disableStickyBucketing": z.boolean().optional(), "bucketVersion": z.coerce.number().optional(), "minBucketVersion": z.coerce.number().optional(), "namespace": z.object({ "enabled": z.boolean(), "name": z.string(), "range": z.array(z.coerce.number()).min(2).max(2) }).optional(), "coverage": z.coerce.number().optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional(), "value": z.array(z.object({ "value": z.string(), "weight": z.coerce.number(), "name": z.string().optional() })).optional() }), z.object({ "description": z.string(), "id": z.string(), "enabled": z.boolean(), "type": z.literal("experiment-ref"), "condition": z.string().optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional(), "variations": z.array(z.object({ "value": z.string(), "variationId": z.string() })), "experimentId": z.string() }), z.object({ "condition": z.string(), "savedGroupTargeting": z.array(z.object({ "matchType": z.enum(["all","any","none"]), "savedGroups": z.array(z.string()) })).optional(), "prerequisites": z.array(z.object({ "id": z.string().describe("Feature ID"), "condition": z.string() })).optional(), "id": z.string(), "trackingKey": z.string().optional(), "enabled": z.boolean(), "type": z.literal("safe-rollout"), "controlValue": z.string(), "variationValue": z.string(), "seed": z.string().optional(), "hashAttribute": z.string().optional(), "safeRolloutId": z.string().optional(), "status": z.enum(["running","released","rolled-back","stopped"]).optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional() })])), "definition": z.string().describe("A JSON stringified [FeatureDefinition](#tag/FeatureDefinition_model)").optional() }).optional() })), "prerequisites": z.array(z.string()).describe("Feature IDs. Each feature must evaluate to `true`").optional(), "revision": z.object({ "version": z.coerce.number().int(), "comment": z.string(), "date": z.string(), "publishedBy": z.string() }), "customFields": z.record(z.string(), z.any()).optional() }), z.object({ "revisions": z.array(z.object({ "baseVersion": z.coerce.number().int(), "version": z.coerce.number().int(), "comment": z.string(), "date": z.string(), "status": z.string(), "publishedBy": z.string().optional(), "rules": z.record(z.string(), z.array(z.union([z.object({ "description": z.string(), "condition": z.string(), "savedGroupTargeting": z.array(z.object({ "matchType": z.enum(["all","any","none"]), "savedGroups": z.array(z.string()) })).optional(), "prerequisites": z.array(z.object({ "id": z.string().describe("Feature ID"), "condition": z.string() })).optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional(), "id": z.string(), "enabled": z.boolean(), "type": z.literal("force"), "value": z.string() }), z.object({ "description": z.string(), "condition": z.string(), "savedGroupTargeting": z.array(z.object({ "matchType": z.enum(["all","any","none"]), "savedGroups": z.array(z.string()) })).optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional(), "id": z.string(), "enabled": z.boolean(), "type": z.literal("rollout"), "value": z.string(), "coverage": z.coerce.number(), "hashAttribute": z.string() }), z.object({ "description": z.string(), "condition": z.string(), "id": z.string(), "enabled": z.boolean(), "type": z.literal("experiment"), "trackingKey": z.string().optional(), "hashAttribute": z.string().optional(), "fallbackAttribute": z.string().optional(), "disableStickyBucketing": z.boolean().optional(), "bucketVersion": z.coerce.number().optional(), "minBucketVersion": z.coerce.number().optional(), "namespace": z.object({ "enabled": z.boolean(), "name": z.string(), "range": z.array(z.coerce.number()).min(2).max(2) }).optional(), "coverage": z.coerce.number().optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional(), "value": z.array(z.object({ "value": z.string(), "weight": z.coerce.number(), "name": z.string().optional() })).optional() }), z.object({ "description": z.string(), "id": z.string(), "enabled": z.boolean(), "type": z.literal("experiment-ref"), "condition": z.string().optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional(), "variations": z.array(z.object({ "value": z.string(), "variationId": z.string() })), "experimentId": z.string() }), z.object({ "condition": z.string(), "savedGroupTargeting": z.array(z.object({ "matchType": z.enum(["all","any","none"]), "savedGroups": z.array(z.string()) })).optional(), "prerequisites": z.array(z.object({ "id": z.string().describe("Feature ID"), "condition": z.string() })).optional(), "id": z.string(), "trackingKey": z.string().optional(), "enabled": z.boolean(), "type": z.literal("safe-rollout"), "controlValue": z.string(), "variationValue": z.string(), "seed": z.string().optional(), "hashAttribute": z.string().optional(), "safeRolloutId": z.string().optional(), "status": z.enum(["running","released","rolled-back","stopped"]).optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional() })]))), "definitions": z.record(z.string(), z.string().describe("A JSON stringified [FeatureDefinition](#tag/FeatureDefinition_model)")).optional() })).optional() }))

export const apiFeatureEnvironmentValidator = z.object({ "enabled": z.boolean(), "defaultValue": z.string(), "rules": z.array(z.union([z.object({ "description": z.string(), "condition": z.string(), "savedGroupTargeting": z.array(z.object({ "matchType": z.enum(["all","any","none"]), "savedGroups": z.array(z.string()) })).optional(), "prerequisites": z.array(z.object({ "id": z.string().describe("Feature ID"), "condition": z.string() })).optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional(), "id": z.string(), "enabled": z.boolean(), "type": z.literal("force"), "value": z.string() }), z.object({ "description": z.string(), "condition": z.string(), "savedGroupTargeting": z.array(z.object({ "matchType": z.enum(["all","any","none"]), "savedGroups": z.array(z.string()) })).optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional(), "id": z.string(), "enabled": z.boolean(), "type": z.literal("rollout"), "value": z.string(), "coverage": z.coerce.number(), "hashAttribute": z.string() }), z.object({ "description": z.string(), "condition": z.string(), "id": z.string(), "enabled": z.boolean(), "type": z.literal("experiment"), "trackingKey": z.string().optional(), "hashAttribute": z.string().optional(), "fallbackAttribute": z.string().optional(), "disableStickyBucketing": z.boolean().optional(), "bucketVersion": z.coerce.number().optional(), "minBucketVersion": z.coerce.number().optional(), "namespace": z.object({ "enabled": z.boolean(), "name": z.string(), "range": z.array(z.coerce.number()).min(2).max(2) }).optional(), "coverage": z.coerce.number().optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional(), "value": z.array(z.object({ "value": z.string(), "weight": z.coerce.number(), "name": z.string().optional() })).optional() }), z.object({ "description": z.string(), "id": z.string(), "enabled": z.boolean(), "type": z.literal("experiment-ref"), "condition": z.string().optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional(), "variations": z.array(z.object({ "value": z.string(), "variationId": z.string() })), "experimentId": z.string() }), z.object({ "condition": z.string(), "savedGroupTargeting": z.array(z.object({ "matchType": z.enum(["all","any","none"]), "savedGroups": z.array(z.string()) })).optional(), "prerequisites": z.array(z.object({ "id": z.string().describe("Feature ID"), "condition": z.string() })).optional(), "id": z.string(), "trackingKey": z.string().optional(), "enabled": z.boolean(), "type": z.literal("safe-rollout"), "controlValue": z.string(), "variationValue": z.string(), "seed": z.string().optional(), "hashAttribute": z.string().optional(), "safeRolloutId": z.string().optional(), "status": z.enum(["running","released","rolled-back","stopped"]).optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional() })])), "definition": z.string().describe("A JSON stringified [FeatureDefinition](#tag/FeatureDefinition_model)").optional(), "draft": z.object({ "enabled": z.boolean(), "defaultValue": z.string(), "rules": z.array(z.union([z.object({ "description": z.string(), "condition": z.string(), "savedGroupTargeting": z.array(z.object({ "matchType": z.enum(["all","any","none"]), "savedGroups": z.array(z.string()) })).optional(), "prerequisites": z.array(z.object({ "id": z.string().describe("Feature ID"), "condition": z.string() })).optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional(), "id": z.string(), "enabled": z.boolean(), "type": z.literal("force"), "value": z.string() }), z.object({ "description": z.string(), "condition": z.string(), "savedGroupTargeting": z.array(z.object({ "matchType": z.enum(["all","any","none"]), "savedGroups": z.array(z.string()) })).optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional(), "id": z.string(), "enabled": z.boolean(), "type": z.literal("rollout"), "value": z.string(), "coverage": z.coerce.number(), "hashAttribute": z.string() }), z.object({ "description": z.string(), "condition": z.string(), "id": z.string(), "enabled": z.boolean(), "type": z.literal("experiment"), "trackingKey": z.string().optional(), "hashAttribute": z.string().optional(), "fallbackAttribute": z.string().optional(), "disableStickyBucketing": z.boolean().optional(), "bucketVersion": z.coerce.number().optional(), "minBucketVersion": z.coerce.number().optional(), "namespace": z.object({ "enabled": z.boolean(), "name": z.string(), "range": z.array(z.coerce.number()).min(2).max(2) }).optional(), "coverage": z.coerce.number().optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional(), "value": z.array(z.object({ "value": z.string(), "weight": z.coerce.number(), "name": z.string().optional() })).optional() }), z.object({ "description": z.string(), "id": z.string(), "enabled": z.boolean(), "type": z.literal("experiment-ref"), "condition": z.string().optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional(), "variations": z.array(z.object({ "value": z.string(), "variationId": z.string() })), "experimentId": z.string() }), z.object({ "condition": z.string(), "savedGroupTargeting": z.array(z.object({ "matchType": z.enum(["all","any","none"]), "savedGroups": z.array(z.string()) })).optional(), "prerequisites": z.array(z.object({ "id": z.string().describe("Feature ID"), "condition": z.string() })).optional(), "id": z.string(), "trackingKey": z.string().optional(), "enabled": z.boolean(), "type": z.literal("safe-rollout"), "controlValue": z.string(), "variationValue": z.string(), "seed": z.string().optional(), "hashAttribute": z.string().optional(), "safeRolloutId": z.string().optional(), "status": z.enum(["running","released","rolled-back","stopped"]).optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional() })])), "definition": z.string().describe("A JSON stringified [FeatureDefinition](#tag/FeatureDefinition_model)").optional() }).optional() }).strict()

export const apiFeatureRuleValidator = z.union([z.object({ "description": z.string(), "condition": z.string(), "savedGroupTargeting": z.array(z.object({ "matchType": z.enum(["all","any","none"]), "savedGroups": z.array(z.string()) })).optional(), "prerequisites": z.array(z.object({ "id": z.string().describe("Feature ID"), "condition": z.string() })).optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional(), "id": z.string(), "enabled": z.boolean(), "type": z.literal("force"), "value": z.string() }), z.object({ "description": z.string(), "condition": z.string(), "savedGroupTargeting": z.array(z.object({ "matchType": z.enum(["all","any","none"]), "savedGroups": z.array(z.string()) })).optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional(), "id": z.string(), "enabled": z.boolean(), "type": z.literal("rollout"), "value": z.string(), "coverage": z.coerce.number(), "hashAttribute": z.string() }), z.object({ "description": z.string(), "condition": z.string(), "id": z.string(), "enabled": z.boolean(), "type": z.literal("experiment"), "trackingKey": z.string().optional(), "hashAttribute": z.string().optional(), "fallbackAttribute": z.string().optional(), "disableStickyBucketing": z.boolean().optional(), "bucketVersion": z.coerce.number().optional(), "minBucketVersion": z.coerce.number().optional(), "namespace": z.object({ "enabled": z.boolean(), "name": z.string(), "range": z.array(z.coerce.number()).min(2).max(2) }).optional(), "coverage": z.coerce.number().optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional(), "value": z.array(z.object({ "value": z.string(), "weight": z.coerce.number(), "name": z.string().optional() })).optional() }), z.object({ "description": z.string(), "id": z.string(), "enabled": z.boolean(), "type": z.literal("experiment-ref"), "condition": z.string().optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional(), "variations": z.array(z.object({ "value": z.string(), "variationId": z.string() })), "experimentId": z.string() }), z.object({ "condition": z.string(), "savedGroupTargeting": z.array(z.object({ "matchType": z.enum(["all","any","none"]), "savedGroups": z.array(z.string()) })).optional(), "prerequisites": z.array(z.object({ "id": z.string().describe("Feature ID"), "condition": z.string() })).optional(), "id": z.string(), "trackingKey": z.string().optional(), "enabled": z.boolean(), "type": z.literal("safe-rollout"), "controlValue": z.string(), "variationValue": z.string(), "seed": z.string().optional(), "hashAttribute": z.string().optional(), "safeRolloutId": z.string().optional(), "status": z.enum(["running","released","rolled-back","stopped"]).optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional() })])

export const apiFeatureDefinitionValidator = z.object({ "defaultValue": z.union([z.string(), z.coerce.number(), z.array(z.any()), z.record(z.string(), z.any()), z.null()]), "rules": z.array(z.object({ "force": z.union([z.string(), z.coerce.number(), z.array(z.any()), z.record(z.string(), z.any()), z.null()]).optional(), "weights": z.array(z.coerce.number()).optional(), "variations": z.array(z.union([z.string(), z.coerce.number(), z.array(z.any()), z.record(z.string(), z.any()), z.null()])).optional(), "hashAttribute": z.string().optional(), "namespace": z.array(z.union([z.coerce.number(), z.string()])).min(3).max(3).optional(), "key": z.string().optional(), "coverage": z.coerce.number().optional(), "condition": z.record(z.string(), z.any()).optional() })).optional() }).strict()

export const apiFeatureForceRuleValidator = z.object({ "description": z.string(), "condition": z.string(), "savedGroupTargeting": z.array(z.object({ "matchType": z.enum(["all","any","none"]), "savedGroups": z.array(z.string()) })).optional(), "prerequisites": z.array(z.object({ "id": z.string().describe("Feature ID"), "condition": z.string() })).optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional(), "id": z.string(), "enabled": z.boolean(), "type": z.literal("force"), "value": z.string() }).strict()

export const apiFeatureRolloutRuleValidator = z.object({ "description": z.string(), "condition": z.string(), "savedGroupTargeting": z.array(z.object({ "matchType": z.enum(["all","any","none"]), "savedGroups": z.array(z.string()) })).optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional(), "id": z.string(), "enabled": z.boolean(), "type": z.literal("rollout"), "value": z.string(), "coverage": z.coerce.number(), "hashAttribute": z.string() }).strict()

export const apiFeatureSafeRolloutRuleValidator = z.object({ "condition": z.string(), "savedGroupTargeting": z.array(z.object({ "matchType": z.enum(["all","any","none"]), "savedGroups": z.array(z.string()) })).optional(), "prerequisites": z.array(z.object({ "id": z.string().describe("Feature ID"), "condition": z.string() })).optional(), "id": z.string(), "trackingKey": z.string().optional(), "enabled": z.boolean(), "type": z.literal("safe-rollout"), "controlValue": z.string(), "variationValue": z.string(), "seed": z.string().optional(), "hashAttribute": z.string().optional(), "safeRolloutId": z.string().optional(), "status": z.enum(["running","released","rolled-back","stopped"]).optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional() }).strict()

export const apiFeatureExperimentRuleValidator = z.object({ "description": z.string(), "condition": z.string(), "id": z.string(), "enabled": z.boolean(), "type": z.literal("experiment"), "trackingKey": z.string().optional(), "hashAttribute": z.string().optional(), "fallbackAttribute": z.string().optional(), "disableStickyBucketing": z.boolean().optional(), "bucketVersion": z.coerce.number().optional(), "minBucketVersion": z.coerce.number().optional(), "namespace": z.object({ "enabled": z.boolean(), "name": z.string(), "range": z.array(z.coerce.number()).min(2).max(2) }).optional(), "coverage": z.coerce.number().optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional(), "value": z.array(z.object({ "value": z.string(), "weight": z.coerce.number(), "name": z.string().optional() })).optional() }).strict()

export const apiFeatureExperimentRefRuleValidator = z.object({ "description": z.string(), "id": z.string(), "enabled": z.boolean(), "type": z.literal("experiment-ref"), "condition": z.string().optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional(), "variations": z.array(z.object({ "value": z.string(), "variationId": z.string() })), "experimentId": z.string() }).strict()

export const apiFeatureRevisionValidator = z.object({ "baseVersion": z.coerce.number().int(), "version": z.coerce.number().int(), "comment": z.string(), "date": z.string(), "status": z.string(), "publishedBy": z.string().optional(), "rules": z.record(z.string(), z.array(z.union([z.object({ "description": z.string(), "condition": z.string(), "savedGroupTargeting": z.array(z.object({ "matchType": z.enum(["all","any","none"]), "savedGroups": z.array(z.string()) })).optional(), "prerequisites": z.array(z.object({ "id": z.string().describe("Feature ID"), "condition": z.string() })).optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional(), "id": z.string(), "enabled": z.boolean(), "type": z.literal("force"), "value": z.string() }), z.object({ "description": z.string(), "condition": z.string(), "savedGroupTargeting": z.array(z.object({ "matchType": z.enum(["all","any","none"]), "savedGroups": z.array(z.string()) })).optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional(), "id": z.string(), "enabled": z.boolean(), "type": z.literal("rollout"), "value": z.string(), "coverage": z.coerce.number(), "hashAttribute": z.string() }), z.object({ "description": z.string(), "condition": z.string(), "id": z.string(), "enabled": z.boolean(), "type": z.literal("experiment"), "trackingKey": z.string().optional(), "hashAttribute": z.string().optional(), "fallbackAttribute": z.string().optional(), "disableStickyBucketing": z.boolean().optional(), "bucketVersion": z.coerce.number().optional(), "minBucketVersion": z.coerce.number().optional(), "namespace": z.object({ "enabled": z.boolean(), "name": z.string(), "range": z.array(z.coerce.number()).min(2).max(2) }).optional(), "coverage": z.coerce.number().optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional(), "value": z.array(z.object({ "value": z.string(), "weight": z.coerce.number(), "name": z.string().optional() })).optional() }), z.object({ "description": z.string(), "id": z.string(), "enabled": z.boolean(), "type": z.literal("experiment-ref"), "condition": z.string().optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional(), "variations": z.array(z.object({ "value": z.string(), "variationId": z.string() })), "experimentId": z.string() }), z.object({ "condition": z.string(), "savedGroupTargeting": z.array(z.object({ "matchType": z.enum(["all","any","none"]), "savedGroups": z.array(z.string()) })).optional(), "prerequisites": z.array(z.object({ "id": z.string().describe("Feature ID"), "condition": z.string() })).optional(), "id": z.string(), "trackingKey": z.string().optional(), "enabled": z.boolean(), "type": z.literal("safe-rollout"), "controlValue": z.string(), "variationValue": z.string(), "seed": z.string().optional(), "hashAttribute": z.string().optional(), "safeRolloutId": z.string().optional(), "status": z.enum(["running","released","rolled-back","stopped"]).optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional() })]))), "definitions": z.record(z.string(), z.string().describe("A JSON stringified [FeatureDefinition](#tag/FeatureDefinition_model)")).optional() }).strict()

export const apiSdkConnectionValidator = z.object({ "id": z.string(), "dateCreated": z.string(), "dateUpdated": z.string(), "name": z.string(), "organization": z.string(), "languages": z.array(z.string()), "sdkVersion": z.string().optional(), "environment": z.string(), "project": z.string().describe("Use 'projects' instead. This is only for backwards compatibility and contains the first project only."), "projects": z.array(z.string()).optional(), "encryptPayload": z.boolean(), "encryptionKey": z.string(), "includeVisualExperiments": z.boolean().optional(), "includeDraftExperiments": z.boolean().optional(), "includeExperimentNames": z.boolean().optional(), "includeRedirectExperiments": z.boolean().optional(), "includeRuleIds": z.boolean().optional(), "includeProjectPublicId": z.boolean().optional(), "includeCustomFields": z.array(z.string()).optional(), "includeTags": z.boolean().optional(), "key": z.string(), "proxyEnabled": z.boolean(), "proxyHost": z.string(), "proxySigningKey": z.string(), "sseEnabled": z.boolean().optional(), "hashSecureAttributes": z.boolean().optional(), "remoteEvalEnabled": z.boolean().optional(), "savedGroupReferencesEnabled": z.boolean().optional() }).strict()

export const apiExperimentValidator = z.object({ "id": z.string(), "trackingKey": z.string(), "dateCreated": z.string(), "dateUpdated": z.string(), "name": z.string(), "type": z.enum(["standard","multi-armed-bandit"]), "project": z.string(), "hypothesis": z.string(), "description": z.string(), "tags": z.array(z.string()), "owner": z.string(), "archived": z.boolean(), "status": z.string(), "autoRefresh": z.boolean(), "hashAttribute": z.string(), "fallbackAttribute": z.string().optional(), "hashVersion": z.union([z.literal(1), z.literal(2)]), "disableStickyBucketing": z.boolean().optional(), "bucketVersion": z.coerce.number().optional(), "minBucketVersion": z.coerce.number().optional(), "variations": z.array(z.object({ "variationId": z.string(), "key": z.string(), "name": z.string(), "description": z.string(), "screenshots": z.array(z.string()) })), "phases": z.array(z.object({ "name": z.string(), "dateStarted": z.string(), "dateEnded": z.string(), "reasonForStopping": z.string(), "seed": z.string(), "coverage": z.coerce.number(), "trafficSplit": z.array(z.object({ "variationId": z.string(), "weight": z.coerce.number() })), "namespace": z.object({ "namespaceId": z.string(), "range": z.array(z.any()) }).optional(), "targetingCondition": z.string(), "prerequisites": z.array(z.object({ "id": z.string(), "condition": z.string() })).optional(), "savedGroupTargeting": z.array(z.object({ "matchType": z.enum(["all","any","none"]), "savedGroups": z.array(z.string()) })).optional() })), "settings": z.object({ "datasourceId": z.string(), "assignmentQueryId": z.string(), "experimentId": z.string(), "segmentId": z.string(), "queryFilter": z.string(), "inProgressConversions": z.enum(["include","exclude"]), "attributionModel": z.enum(["firstExposure","experimentDuration"]).describe("Setting attribution model to `\"experimentDuration\"` is the same as selecting \"Ignore Conversion Windows\" for the Conversion Window Override."), "statsEngine": z.enum(["bayesian","frequentist"]), "regressionAdjustmentEnabled": z.boolean().optional(), "sequentialTestingEnabled": z.boolean().optional(), "sequentialTestingTuningParameter": z.coerce.number().optional(), "goals": z.array(z.object({ "metricId": z.string(), "overrides": z.object({ "delayHours": z.coerce.number().optional(), "windowHours": z.coerce.number().optional(), "window": z.enum(["conversion","lookback",""]).optional(), "winRiskThreshold": z.coerce.number().optional(), "loseRiskThreshold": z.coerce.number().optional() }) })), "secondaryMetrics": z.array(z.object({ "metricId": z.string(), "overrides": z.object({ "delayHours": z.coerce.number().optional(), "windowHours": z.coerce.number().optional(), "window": z.enum(["conversion","lookback",""]).optional(), "winRiskThreshold": z.coerce.number().optional(), "loseRiskThreshold": z.coerce.number().optional() }) })), "guardrails": z.array(z.object({ "metricId": z.string(), "overrides": z.object({ "delayHours": z.coerce.number().optional(), "windowHours": z.coerce.number().optional(), "window": z.enum(["conversion","lookback",""]).optional(), "winRiskThreshold": z.coerce.number().optional(), "loseRiskThreshold": z.coerce.number().optional() }) })), "activationMetric": z.object({ "metricId": z.string(), "overrides": z.object({ "delayHours": z.coerce.number().optional(), "windowHours": z.coerce.number().optional(), "window": z.enum(["conversion","lookback",""]).optional(), "winRiskThreshold": z.coerce.number().optional(), "loseRiskThreshold": z.coerce.number().optional() }) }).optional() }), "resultSummary": z.object({ "status": z.string(), "winner": z.string(), "conclusions": z.string(), "releasedVariationId": z.string(), "excludeFromPayload": z.boolean() }).optional(), "shareLevel": z.enum(["public","organization"]).optional(), "publicUrl": z.string().optional(), "banditScheduleValue": z.coerce.number().optional(), "banditScheduleUnit": z.enum(["days","hours"]).optional(), "banditBurnInValue": z.coerce.number().optional(), "banditBurnInUnit": z.enum(["days","hours"]).optional(), "linkedFeatures": z.array(z.string()).optional(), "hasVisualChangesets": z.boolean().optional(), "hasURLRedirects": z.boolean().optional(), "customFields": z.record(z.string(), z.any()).optional(), "pinnedMetricSlices": z.array(z.string()).describe("Array of pinned metric slices in format `{metricId}?dim:{sliceColumn}={sliceLevel}&location={goal|secondary|guardrail}` (URL-encoded)").optional(), "customMetricSlices": z.array(z.object({ "slices": z.array(z.object({ "column": z.string(), "levels": z.array(z.string()) })) })).describe("Custom slices that apply to ALL applicable metrics in the experiment").optional() }).strict()

export const apiExperimentSnapshotValidator = z.object({ "id": z.string(), "experiment": z.string(), "status": z.string() }).strict()

export const apiExperimentMetricValidator = z.object({ "metricId": z.string(), "overrides": z.object({ "delayHours": z.coerce.number().optional(), "windowHours": z.coerce.number().optional(), "window": z.enum(["conversion","lookback",""]).optional(), "winRiskThreshold": z.coerce.number().optional(), "loseRiskThreshold": z.coerce.number().optional() }) }).strict()

export const apiExperimentAnalysisSettingsValidator = z.object({ "datasourceId": z.string(), "assignmentQueryId": z.string(), "experimentId": z.string(), "segmentId": z.string(), "queryFilter": z.string(), "inProgressConversions": z.enum(["include","exclude"]), "attributionModel": z.enum(["firstExposure","experimentDuration"]).describe("Setting attribution model to `\"experimentDuration\"` is the same as selecting \"Ignore Conversion Windows\" for the Conversion Window Override."), "statsEngine": z.enum(["bayesian","frequentist"]), "regressionAdjustmentEnabled": z.boolean().optional(), "sequentialTestingEnabled": z.boolean().optional(), "sequentialTestingTuningParameter": z.coerce.number().optional(), "goals": z.array(z.object({ "metricId": z.string(), "overrides": z.object({ "delayHours": z.coerce.number().optional(), "windowHours": z.coerce.number().optional(), "window": z.enum(["conversion","lookback",""]).optional(), "winRiskThreshold": z.coerce.number().optional(), "loseRiskThreshold": z.coerce.number().optional() }) })), "secondaryMetrics": z.array(z.object({ "metricId": z.string(), "overrides": z.object({ "delayHours": z.coerce.number().optional(), "windowHours": z.coerce.number().optional(), "window": z.enum(["conversion","lookback",""]).optional(), "winRiskThreshold": z.coerce.number().optional(), "loseRiskThreshold": z.coerce.number().optional() }) })), "guardrails": z.array(z.object({ "metricId": z.string(), "overrides": z.object({ "delayHours": z.coerce.number().optional(), "windowHours": z.coerce.number().optional(), "window": z.enum(["conversion","lookback",""]).optional(), "winRiskThreshold": z.coerce.number().optional(), "loseRiskThreshold": z.coerce.number().optional() }) })), "activationMetric": z.object({ "metricId": z.string(), "overrides": z.object({ "delayHours": z.coerce.number().optional(), "windowHours": z.coerce.number().optional(), "window": z.enum(["conversion","lookback",""]).optional(), "winRiskThreshold": z.coerce.number().optional(), "loseRiskThreshold": z.coerce.number().optional() }) }).optional() }).strict()

export const apiExperimentResultsValidator = z.object({ "id": z.string(), "dateUpdated": z.string(), "experimentId": z.string(), "phase": z.string(), "dateStart": z.string(), "dateEnd": z.string(), "dimension": z.object({ "type": z.string(), "id": z.string().optional() }), "settings": z.object({ "datasourceId": z.string(), "assignmentQueryId": z.string(), "experimentId": z.string(), "segmentId": z.string(), "queryFilter": z.string(), "inProgressConversions": z.enum(["include","exclude"]), "attributionModel": z.enum(["firstExposure","experimentDuration"]).describe("Setting attribution model to `\"experimentDuration\"` is the same as selecting \"Ignore Conversion Windows\" for the Conversion Window Override."), "statsEngine": z.enum(["bayesian","frequentist"]), "regressionAdjustmentEnabled": z.boolean().optional(), "sequentialTestingEnabled": z.boolean().optional(), "sequentialTestingTuningParameter": z.coerce.number().optional(), "goals": z.array(z.object({ "metricId": z.string(), "overrides": z.object({ "delayHours": z.coerce.number().optional(), "windowHours": z.coerce.number().optional(), "window": z.enum(["conversion","lookback",""]).optional(), "winRiskThreshold": z.coerce.number().optional(), "loseRiskThreshold": z.coerce.number().optional() }) })), "secondaryMetrics": z.array(z.object({ "metricId": z.string(), "overrides": z.object({ "delayHours": z.coerce.number().optional(), "windowHours": z.coerce.number().optional(), "window": z.enum(["conversion","lookback",""]).optional(), "winRiskThreshold": z.coerce.number().optional(), "loseRiskThreshold": z.coerce.number().optional() }) })), "guardrails": z.array(z.object({ "metricId": z.string(), "overrides": z.object({ "delayHours": z.coerce.number().optional(), "windowHours": z.coerce.number().optional(), "window": z.enum(["conversion","lookback",""]).optional(), "winRiskThreshold": z.coerce.number().optional(), "loseRiskThreshold": z.coerce.number().optional() }) })), "activationMetric": z.object({ "metricId": z.string(), "overrides": z.object({ "delayHours": z.coerce.number().optional(), "windowHours": z.coerce.number().optional(), "window": z.enum(["conversion","lookback",""]).optional(), "winRiskThreshold": z.coerce.number().optional(), "loseRiskThreshold": z.coerce.number().optional() }) }).optional() }), "queryIds": z.array(z.string()), "results": z.array(z.object({ "dimension": z.string(), "totalUsers": z.coerce.number(), "checks": z.object({ "srm": z.coerce.number() }), "metrics": z.array(z.object({ "metricId": z.string(), "variations": z.array(z.object({ "variationId": z.string(), "users": z.coerce.number().optional(), "analyses": z.array(z.object({ "engine": z.enum(["bayesian","frequentist"]), "numerator": z.coerce.number(), "denominator": z.coerce.number(), "mean": z.coerce.number(), "stddev": z.coerce.number(), "percentChange": z.coerce.number(), "ciLow": z.coerce.number(), "ciHigh": z.coerce.number(), "pValue": z.coerce.number().optional(), "risk": z.coerce.number().optional(), "chanceToBeatControl": z.coerce.number().optional() })) })) })) })) }).strict()

export const apiExperimentWithEnhancedStatusValidator = z.intersection(z.object({ "id": z.string(), "trackingKey": z.string(), "dateCreated": z.string(), "dateUpdated": z.string(), "name": z.string(), "type": z.enum(["standard","multi-armed-bandit"]), "project": z.string(), "hypothesis": z.string(), "description": z.string(), "tags": z.array(z.string()), "owner": z.string(), "archived": z.boolean(), "status": z.string(), "autoRefresh": z.boolean(), "hashAttribute": z.string(), "fallbackAttribute": z.string().optional(), "hashVersion": z.union([z.literal(1), z.literal(2)]), "disableStickyBucketing": z.boolean().optional(), "bucketVersion": z.coerce.number().optional(), "minBucketVersion": z.coerce.number().optional(), "variations": z.array(z.object({ "variationId": z.string(), "key": z.string(), "name": z.string(), "description": z.string(), "screenshots": z.array(z.string()) })), "phases": z.array(z.object({ "name": z.string(), "dateStarted": z.string(), "dateEnded": z.string(), "reasonForStopping": z.string(), "seed": z.string(), "coverage": z.coerce.number(), "trafficSplit": z.array(z.object({ "variationId": z.string(), "weight": z.coerce.number() })), "namespace": z.object({ "namespaceId": z.string(), "range": z.array(z.any()) }).optional(), "targetingCondition": z.string(), "prerequisites": z.array(z.object({ "id": z.string(), "condition": z.string() })).optional(), "savedGroupTargeting": z.array(z.object({ "matchType": z.enum(["all","any","none"]), "savedGroups": z.array(z.string()) })).optional() })), "settings": z.object({ "datasourceId": z.string(), "assignmentQueryId": z.string(), "experimentId": z.string(), "segmentId": z.string(), "queryFilter": z.string(), "inProgressConversions": z.enum(["include","exclude"]), "attributionModel": z.enum(["firstExposure","experimentDuration"]).describe("Setting attribution model to `\"experimentDuration\"` is the same as selecting \"Ignore Conversion Windows\" for the Conversion Window Override."), "statsEngine": z.enum(["bayesian","frequentist"]), "regressionAdjustmentEnabled": z.boolean().optional(), "sequentialTestingEnabled": z.boolean().optional(), "sequentialTestingTuningParameter": z.coerce.number().optional(), "goals": z.array(z.object({ "metricId": z.string(), "overrides": z.object({ "delayHours": z.coerce.number().optional(), "windowHours": z.coerce.number().optional(), "window": z.enum(["conversion","lookback",""]).optional(), "winRiskThreshold": z.coerce.number().optional(), "loseRiskThreshold": z.coerce.number().optional() }) })), "secondaryMetrics": z.array(z.object({ "metricId": z.string(), "overrides": z.object({ "delayHours": z.coerce.number().optional(), "windowHours": z.coerce.number().optional(), "window": z.enum(["conversion","lookback",""]).optional(), "winRiskThreshold": z.coerce.number().optional(), "loseRiskThreshold": z.coerce.number().optional() }) })), "guardrails": z.array(z.object({ "metricId": z.string(), "overrides": z.object({ "delayHours": z.coerce.number().optional(), "windowHours": z.coerce.number().optional(), "window": z.enum(["conversion","lookback",""]).optional(), "winRiskThreshold": z.coerce.number().optional(), "loseRiskThreshold": z.coerce.number().optional() }) })), "activationMetric": z.object({ "metricId": z.string(), "overrides": z.object({ "delayHours": z.coerce.number().optional(), "windowHours": z.coerce.number().optional(), "window": z.enum(["conversion","lookback",""]).optional(), "winRiskThreshold": z.coerce.number().optional(), "loseRiskThreshold": z.coerce.number().optional() }) }).optional() }), "resultSummary": z.object({ "status": z.string(), "winner": z.string(), "conclusions": z.string(), "releasedVariationId": z.string(), "excludeFromPayload": z.boolean() }).optional(), "shareLevel": z.enum(["public","organization"]).optional(), "publicUrl": z.string().optional(), "banditScheduleValue": z.coerce.number().optional(), "banditScheduleUnit": z.enum(["days","hours"]).optional(), "banditBurnInValue": z.coerce.number().optional(), "banditBurnInUnit": z.enum(["days","hours"]).optional(), "linkedFeatures": z.array(z.string()).optional(), "hasVisualChangesets": z.boolean().optional(), "hasURLRedirects": z.boolean().optional(), "customFields": z.record(z.string(), z.any()).optional(), "pinnedMetricSlices": z.array(z.string()).describe("Array of pinned metric slices in format `{metricId}?dim:{sliceColumn}={sliceLevel}&location={goal|secondary|guardrail}` (URL-encoded)").optional(), "customMetricSlices": z.array(z.object({ "slices": z.array(z.object({ "column": z.string(), "levels": z.array(z.string()) })) })).describe("Custom slices that apply to ALL applicable metrics in the experiment").optional() }), z.object({ "enhancedStatus": z.object({ "status": z.enum(["Running","Stopped","Draft","Archived"]), "detailedStatus": z.string().optional() }).optional() }))

export const apiDataSourceValidator = z.object({ "id": z.string(), "dateCreated": z.string(), "dateUpdated": z.string(), "type": z.string(), "name": z.string(), "description": z.string(), "projectIds": z.array(z.string()), "eventTracker": z.string(), "identifierTypes": z.array(z.object({ "id": z.string(), "description": z.string() })), "assignmentQueries": z.array(z.object({ "id": z.string(), "name": z.string(), "description": z.string(), "identifierType": z.string(), "sql": z.string(), "includesNameColumns": z.boolean(), "dimensionColumns": z.array(z.string()) })), "identifierJoinQueries": z.array(z.object({ "identifierTypes": z.array(z.string()), "sql": z.string() })), "mixpanelSettings": z.object({ "viewedExperimentEventName": z.string(), "experimentIdProperty": z.string(), "variationIdProperty": z.string(), "extraUserIdProperty": z.string() }).optional() }).strict()

export const apiVisualChangesetValidator = z.object({ "id": z.string().optional(), "urlPatterns": z.array(z.object({ "include": z.boolean().optional(), "type": z.enum(["simple","regex"]), "pattern": z.string() })), "editorUrl": z.string(), "experiment": z.string(), "visualChanges": z.array(z.object({ "description": z.string().optional(), "css": z.string().optional(), "js": z.string().optional(), "variation": z.string(), "domMutations": z.array(z.object({ "selector": z.string(), "action": z.enum(["append","set","remove"]), "attribute": z.string(), "value": z.string().optional(), "parentSelector": z.string().optional(), "insertBeforeSelector": z.string().optional() })) })) }).strict()

export const apiVisualChangeValidator = z.object({ "description": z.string().optional(), "css": z.string().optional(), "js": z.string().optional(), "variation": z.string(), "domMutations": z.array(z.object({ "selector": z.string(), "action": z.enum(["append","set","remove"]), "attribute": z.string(), "value": z.string().optional(), "parentSelector": z.string().optional(), "insertBeforeSelector": z.string().optional() })).optional() }).strict()

export const apiSavedGroupValidator = z.object({ "id": z.string(), "type": z.enum(["condition","list"]), "dateCreated": z.string(), "dateUpdated": z.string(), "name": z.string(), "owner": z.string().optional(), "condition": z.string().describe("When type = 'condition', this is the JSON-encoded condition for the group").optional(), "attributeKey": z.string().describe("When type = 'list', this is the attribute key the group is based on").optional(), "values": z.array(z.string()).describe("When type = 'list', this is the list of values for the attribute key").optional(), "description": z.string().optional(), "projects": z.array(z.string()).optional() }).strict()

export const apiOrganizationValidator = z.object({ "id": z.string().describe("The Growthbook unique identifier for the organization").optional(), "externalId": z.string().describe("An optional identifier that you use within your company for the organization").optional(), "dateCreated": z.string().describe("The date the organization was created").optional(), "name": z.string().describe("The name of the organization").optional(), "ownerEmail": z.string().describe("The email address of the organization owner").optional() }).strict()

export const apiFactTableValidator = z.object({ "id": z.string(), "name": z.string(), "description": z.string(), "owner": z.string(), "projects": z.array(z.string()), "tags": z.array(z.string()), "datasource": z.string(), "userIdTypes": z.array(z.string()), "sql": z.string(), "eventName": z.string().describe("The event name used in SQL template variables").optional(), "columns": z.array(z.object({ "column": z.string().describe("The actual column name in the database/SQL query"), "datatype": z.enum(["number","string","date","boolean","json","other",""]), "numberFormat": z.enum(["","currency","time:seconds","memory:bytes","memory:kilobytes"]).optional(), "jsonFields": z.record(z.string(), z.object({ "datatype": z.enum(["number","string","date","boolean","json","other",""]).optional() })).describe("For JSON columns, defines the structure of nested fields").optional(), "name": z.string().describe("Display name for the column (can be different from the actual column name)").optional(), "description": z.string().optional(), "alwaysInlineFilter": z.boolean().describe("Whether this column should always be included as an inline filter in queries").default(false), "deleted": z.boolean().default(false), "isAutoSliceColumn": z.boolean().describe("Whether this column can be used for auto slice analysis. This is an enterprise feature.").default(false), "autoSlices": z.array(z.string()).describe("Specific slices to automatically analyze for this column.").optional(), "dateCreated": z.string().readonly().optional(), "dateUpdated": z.string().readonly().optional() })).describe("Array of column definitions for this fact table").optional(), "columnsError": z.string().nullable().describe("Error message if there was an issue parsing the SQL schema").optional(), "archived": z.boolean().optional(), "managedBy": z.enum(["","api","admin"]).describe("Where this fact table must be managed from. If not set (empty string), it can be managed from anywhere."), "dateCreated": z.string(), "dateUpdated": z.string() }).strict()

export const apiFactTableColumnValidator = z.object({ "column": z.string().describe("The actual column name in the database/SQL query"), "datatype": z.enum(["number","string","date","boolean","json","other",""]), "numberFormat": z.enum(["","currency","time:seconds","memory:bytes","memory:kilobytes"]).optional(), "jsonFields": z.record(z.string(), z.object({ "datatype": z.enum(["number","string","date","boolean","json","other",""]).optional() })).describe("For JSON columns, defines the structure of nested fields").optional(), "name": z.string().describe("Display name for the column (can be different from the actual column name)").optional(), "description": z.string().optional(), "alwaysInlineFilter": z.boolean().describe("Whether this column should always be included as an inline filter in queries").default(false), "deleted": z.boolean().default(false), "isAutoSliceColumn": z.boolean().describe("Whether this column can be used for auto slice analysis. This is an enterprise feature.").default(false), "autoSlices": z.array(z.string()).describe("Specific slices to automatically analyze for this column.").optional(), "dateCreated": z.string().readonly().optional(), "dateUpdated": z.string().readonly().optional() }).strict()

export const apiFactTableFilterValidator = z.object({ "id": z.string(), "name": z.string(), "description": z.string(), "value": z.string(), "managedBy": z.enum(["","api"]).describe("Where this fact table filter must be managed from. If not set (empty string), it can be managed from anywhere."), "dateCreated": z.string(), "dateUpdated": z.string() }).strict()

export const apiFactMetricValidator = z.object({ "id": z.string(), "name": z.string(), "description": z.string(), "owner": z.string(), "projects": z.array(z.string()), "tags": z.array(z.string()), "datasource": z.string(), "metricType": z.enum(["proportion","retention","mean","quantile","ratio","dailyParticipation"]), "numerator": z.object({ "factTableId": z.string(), "column": z.string(), "aggregation": z.enum(["sum","max","count distinct"]).optional(), "filters": z.array(z.string()).describe("Array of Fact Table Filter Ids. Deprecated, use rowFilters instead.").optional(), "inlineFilters": z.record(z.string(), z.array(z.string())).describe("Inline filters to apply to the fact table. Keys are column names, values are arrays of values to filter by. Deprecated, use rowFilters instead.").optional(), "rowFilters": z.array(z.object({ "operator": z.enum(["=","!=",">","<",">=","<=","in","not_in","is_null","not_null","is_true","is_false","contains","not_contains","starts_with","ends_with","sql_expr","saved_filter"]), "values": z.array(z.string()).describe("Not required for is_null, not_null, is_true, is_false operators.").optional(), "column": z.string().describe("Required for all operators except sql_expr and saved_filter.").optional() })).describe("Filters to apply to the rows of the fact table before aggregation.").optional(), "aggregateFilterColumn": z.string().describe("Column to use to filter users after aggregation. Either '$$count' of rows or the name of a numeric column that will be summed by user. Must specify `aggregateFilter` if using this. Only can be used with 'retention' and 'proportion' metrics.").optional(), "aggregateFilter": z.string().describe("Simple comparison operator and value to apply after aggregation (e.g. '= 10' or '>= 1'). Requires `aggregateFilterColumn`.").optional() }), "denominator": z.object({ "factTableId": z.string(), "column": z.string(), "filters": z.array(z.string()).describe("Array of Fact Table Filter Ids. Deprecated, use rowFilters instead.").optional(), "inlineFilters": z.record(z.string(), z.array(z.string())).describe("Inline filters to apply to the fact table. Keys are column names, values are arrays of values to filter by. Deprecated, use rowFilters instead.").optional(), "rowFilters": z.array(z.object({ "operator": z.enum(["=","!=",">","<",">=","<=","in","not_in","is_null","not_null","is_true","is_false","contains","not_contains","starts_with","ends_with","sql_expr","saved_filter"]), "values": z.array(z.string()).describe("Not required for is_null, not_null, is_true, is_false operators.").optional(), "column": z.string().describe("Required for all operators except sql_expr and saved_filter.").optional() })).describe("Filters to apply to the rows of the fact table before aggregation.").optional() }).optional(), "inverse": z.boolean().describe("Set to true for things like Bounce Rate, where you want the metric to decrease"), "quantileSettings": z.object({ "type": z.enum(["event","unit"]).describe("Whether the quantile is over unit aggregations or raw event values"), "ignoreZeros": z.boolean().describe("If true, zero values will be ignored when calculating the quantile"), "quantile": z.coerce.number().multipleOf(0.001).gte(0.001).lte(0.999).describe("The quantile value (from 0.001 to 0.999)") }).describe("Controls the settings for quantile metrics (mandatory if metricType is \"quantile\")").optional(), "cappingSettings": z.object({ "type": z.enum(["none","absolute","percentile"]), "value": z.coerce.number().describe("When type is absolute, this is the absolute value. When type is percentile, this is the percentile value (from 0.0 to 1.0).").optional(), "ignoreZeros": z.boolean().describe("If true and capping is `percentile`, zeros will be ignored when calculating the percentile.").optional() }).describe("Controls how outliers are handled"), "windowSettings": z.object({ "type": z.enum(["none","conversion","lookback"]), "delayValue": z.coerce.number().describe("Wait this long after experiment exposure before counting conversions.").optional(), "delayUnit": z.enum(["minutes","hours","days","weeks"]).optional(), "windowValue": z.coerce.number().optional(), "windowUnit": z.enum(["minutes","hours","days","weeks"]).optional() }).describe("Controls the conversion window for the metric"), "regressionAdjustmentSettings": z.object({ "override": z.boolean().describe("If false, the organization default settings will be used"), "enabled": z.boolean().describe("Controls whether or not regresion adjustment is applied to the metric").optional(), "days": z.coerce.number().describe("Number of pre-exposure days to use for the regression adjustment").optional() }).describe("Controls the regression adjustment (CUPED) settings for the metric"), "riskThresholdSuccess": z.coerce.number(), "riskThresholdDanger": z.coerce.number(), "displayAsPercentage": z.boolean().describe("If true and the metric is a ratio metric, variation means will be displayed as a percentage").optional(), "minPercentChange": z.coerce.number(), "maxPercentChange": z.coerce.number(), "minSampleSize": z.coerce.number(), "targetMDE": z.coerce.number(), "managedBy": z.enum(["","api","admin"]).describe("Where this fact metric must be managed from. If not set (empty string), it can be managed from anywhere."), "dateCreated": z.string(), "dateUpdated": z.string(), "archived": z.boolean().optional(), "metricAutoSlices": z.array(z.string()).describe("Array of slice column names that will be automatically included in metric analysis. This is an enterprise feature.").optional() }).strict()

export const apiMetricAnalysisValidator = z.object({ "id": z.string().describe("The ID of the created metric analysis"), "status": z.string().describe("The status of the analysis (e.g., \"running\", \"completed\", \"error\")"), "settings": z.record(z.string(), z.any()).optional() }).strict()

export const apiMemberValidator = z.object({ "id": z.string(), "name": z.string().optional(), "email": z.string(), "globalRole": z.string(), "environments": z.array(z.string()).optional(), "limitAccessByEnvironment": z.boolean().optional(), "managedbyIdp": z.boolean().optional(), "teams": z.array(z.string()).optional(), "projectRoles": z.array(z.object({ "project": z.string(), "role": z.string(), "limitAccessByEnvironment": z.boolean(), "environments": z.array(z.string()) })).optional(), "lastLoginDate": z.string().optional(), "dateCreated": z.string().optional(), "dateUpdated": z.string().optional() }).strict()

export const apiArchetypeValidator = z.object({ "id": z.string(), "dateCreated": z.string(), "dateUpdated": z.string(), "name": z.string(), "description": z.string().optional(), "owner": z.string(), "isPublic": z.boolean(), "attributes": z.record(z.string(), z.any()).describe("The attributes to set when using this Archetype"), "projects": z.array(z.string()).optional() }).strict()

export const apiQueryValidator = z.object({ "id": z.string(), "organization": z.string(), "datasource": z.string(), "language": z.string(), "query": z.string(), "queryType": z.string(), "createdAt": z.string(), "startedAt": z.string(), "status": z.enum(["running","queued","failed","partially-succeeded","succeeded"]), "externalId": z.string(), "dependencies": z.array(z.string()), "runAtEnd": z.boolean() }).strict()

export const apiSettingsValidator = z.object({ "confidenceLevel": z.coerce.number(), "northStar": z.object({ "title": z.string().optional(), "metricIds": z.array(z.string()).optional() }).nullable(), "metricDefaults": z.object({ "priorSettings": z.object({ "override": z.boolean(), "proper": z.boolean(), "mean": z.coerce.number(), "stddev": z.coerce.number() }).optional(), "minimumSampleSize": z.coerce.number().optional(), "maxPercentageChange": z.coerce.number().optional(), "minPercentageChange": z.coerce.number().optional(), "targetMDE": z.coerce.number().optional() }), "pastExperimentsMinLength": z.coerce.number(), "metricAnalysisDays": z.coerce.number(), "updateSchedule": z.object({ "type": z.enum(["cron","never","stale"]).optional(), "cron": z.string().nullable().optional(), "hours": z.coerce.number().nullable().optional() }).nullable(), "multipleExposureMinPercent": z.coerce.number(), "defaultRole": z.object({ "role": z.string().optional(), "limitAccessByEnvironment": z.boolean().optional(), "environments": z.array(z.string()).optional() }), "statsEngine": z.string(), "pValueThreshold": z.coerce.number(), "regressionAdjustmentEnabled": z.boolean(), "regressionAdjustmentDays": z.coerce.number(), "sequentialTestingEnabled": z.boolean(), "sequentialTestingTuningParameter": z.coerce.number(), "attributionModel": z.enum(["firstExposure","experimentDuration"]), "targetMDE": z.coerce.number(), "delayHours": z.coerce.number(), "windowType": z.string(), "windowHours": z.coerce.number(), "winRisk": z.coerce.number(), "loseRisk": z.coerce.number(), "secureAttributeSalt": z.string(), "killswitchConfirmation": z.boolean(), "requireReviews": z.array(z.object({ "requireReviewOn": z.boolean().optional(), "resetReviewOnChange": z.boolean().optional(), "environments": z.array(z.string()).optional(), "projects": z.array(z.string()).optional() })), "featureKeyExample": z.string(), "featureRegexValidator": z.string(), "banditScheduleValue": z.coerce.number(), "banditScheduleUnit": z.enum(["hours","days"]), "banditBurnInValue": z.coerce.number(), "banditBurnInUnit": z.enum(["hours","days"]), "experimentMinLengthDays": z.coerce.number(), "experimentMaxLengthDays": z.coerce.number().nullable().optional(), "preferredEnvironment": z.string().nullable().optional(), "maxMetricSliceLevels": z.coerce.number().optional() }).strict()

export const apiCodeRefValidator = z.object({ "organization": z.string().describe("The organization name"), "dateUpdated": z.string().describe("When the code references were last updated"), "feature": z.string().describe("Feature identifier"), "repo": z.string().describe("Repository name"), "branch": z.string().describe("Branch name"), "platform": z.enum(["github","gitlab","bitbucket"]).describe("Source control platform").optional(), "refs": z.array(z.object({ "filePath": z.string().describe("Path to the file containing the reference"), "startingLineNumber": z.coerce.number().int().describe("Line number where the reference starts"), "lines": z.string().describe("The code lines containing the reference"), "flagKey": z.string().describe("The feature flag key referenced") })) }).strict()

export const apiCustomFieldValidator = z.object({ "id": z.string(), "name": z.string(), "type": z.string(), "section": z.string(), "dateCreated": z.string(), "dateUpdated": z.string(), "active": z.boolean(), "required": z.boolean(), "projects": z.array(z.string()).optional(), "values": z.string().optional() }).strict()

export const listFeaturesValidator = {
  bodySchema: z.never(),
  querySchema: z.object({ "limit": z.coerce.number().int().default(10), "offset": z.coerce.number().int().default(0), "projectId": z.string().optional(), "clientKey": z.string().optional() }).strict(),
  paramsSchema: z.never(),
};

export const postFeatureValidator = {
  bodySchema: z.object({ "id": z.string().min(1).describe("A unique key name for the feature. Feature keys can only include letters, numbers, hyphens, and underscores."), "archived": z.boolean().optional(), "description": z.string().describe("Description of the feature").optional(), "owner": z.string().describe("Email of the person who owns this experiment"), "project": z.string().describe("An associated project ID").optional(), "valueType": z.enum(["boolean","string","number","json"]).describe("The data type of the feature payload. Boolean by default."), "defaultValue": z.string().describe("Default value when feature is enabled. Type must match `valueType`."), "tags": z.array(z.string()).describe("List of associated tags").optional(), "environments": z.record(z.string(), z.object({ "enabled": z.boolean(), "rules": z.array(z.union([z.object({ "description": z.string().optional(), "condition": z.string().describe("Applied to everyone by default.").optional(), "savedGroupTargeting": z.array(z.object({ "matchType": z.enum(["all","any","none"]), "savedGroups": z.array(z.string()) })).optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional(), "id": z.string().optional(), "enabled": z.boolean().describe("Enabled by default").optional(), "type": z.literal("force"), "value": z.string() }), z.object({ "description": z.string().optional(), "condition": z.string().describe("Applied to everyone by default.").optional(), "savedGroupTargeting": z.array(z.object({ "matchType": z.enum(["all","any","none"]), "savedGroups": z.array(z.string()) })).optional(), "prerequisites": z.array(z.object({ "id": z.string().describe("Feature ID"), "condition": z.string() })).optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional(), "id": z.string().optional(), "enabled": z.boolean().describe("Enabled by default").optional(), "type": z.literal("rollout"), "value": z.string(), "coverage": z.number().describe("Percent of traffic included in this experiment. Users not included in the experiment will skip this rule."), "hashAttribute": z.string() }), z.object({ "description": z.string().optional(), "id": z.string().optional(), "enabled": z.boolean().describe("Enabled by default").optional(), "type": z.literal("experiment-ref"), "condition": z.string().optional(), "savedGroupTargeting": z.array(z.object({ "matchType": z.enum(["all","any","none"]), "savedGroups": z.array(z.string()) })).optional(), "prerequisites": z.array(z.object({ "id": z.string().describe("Feature ID"), "condition": z.string() })).optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional(), "variations": z.array(z.object({ "value": z.string(), "variationId": z.string() })), "experimentId": z.string() }), z.object({ "description": z.string().optional(), "condition": z.string(), "id": z.string().optional(), "enabled": z.boolean().describe("Enabled by default").optional(), "type": z.literal("experiment"), "trackingKey": z.string().optional(), "hashAttribute": z.string().optional(), "fallbackAttribute": z.string().optional(), "disableStickyBucketing": z.boolean().optional(), "bucketVersion": z.number().optional(), "minBucketVersion": z.number().optional(), "namespace": z.object({ "enabled": z.boolean(), "name": z.string(), "range": z.array(z.number()).min(2).max(2) }).optional(), "coverage": z.number().optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional(), "values": z.array(z.object({ "value": z.string(), "weight": z.number(), "name": z.string().optional() })).optional(), "value": z.array(z.object({ "value": z.string(), "weight": z.number(), "name": z.string().optional() })).describe("Support passing values under the value key as that was the original spec for FeatureExperimentRules").optional() })])), "definition": z.string().describe("A JSON stringified [FeatureDefinition](#tag/FeatureDefinition_model)").optional(), "draft": z.object({ "enabled": z.boolean().optional(), "rules": z.array(z.union([z.object({ "description": z.string().optional(), "condition": z.string().describe("Applied to everyone by default.").optional(), "savedGroupTargeting": z.array(z.object({ "matchType": z.enum(["all","any","none"]), "savedGroups": z.array(z.string()) })).optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional(), "id": z.string().optional(), "enabled": z.boolean().describe("Enabled by default").optional(), "type": z.literal("force"), "value": z.string() }), z.object({ "description": z.string().optional(), "condition": z.string().describe("Applied to everyone by default.").optional(), "savedGroupTargeting": z.array(z.object({ "matchType": z.enum(["all","any","none"]), "savedGroups": z.array(z.string()) })).optional(), "prerequisites": z.array(z.object({ "id": z.string().describe("Feature ID"), "condition": z.string() })).optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional(), "id": z.string().optional(), "enabled": z.boolean().describe("Enabled by default").optional(), "type": z.literal("rollout"), "value": z.string(), "coverage": z.number().describe("Percent of traffic included in this experiment. Users not included in the experiment will skip this rule."), "hashAttribute": z.string() }), z.object({ "description": z.string().optional(), "id": z.string().optional(), "enabled": z.boolean().describe("Enabled by default").optional(), "type": z.literal("experiment-ref"), "condition": z.string().optional(), "savedGroupTargeting": z.array(z.object({ "matchType": z.enum(["all","any","none"]), "savedGroups": z.array(z.string()) })).optional(), "prerequisites": z.array(z.object({ "id": z.string().describe("Feature ID"), "condition": z.string() })).optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional(), "variations": z.array(z.object({ "value": z.string(), "variationId": z.string() })), "experimentId": z.string() }), z.object({ "description": z.string().optional(), "condition": z.string(), "id": z.string().optional(), "enabled": z.boolean().describe("Enabled by default").optional(), "type": z.literal("experiment"), "trackingKey": z.string().optional(), "hashAttribute": z.string().optional(), "fallbackAttribute": z.string().optional(), "disableStickyBucketing": z.boolean().optional(), "bucketVersion": z.number().optional(), "minBucketVersion": z.number().optional(), "namespace": z.object({ "enabled": z.boolean(), "name": z.string(), "range": z.array(z.number()).min(2).max(2) }).optional(), "coverage": z.number().optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional(), "values": z.array(z.object({ "value": z.string(), "weight": z.number(), "name": z.string().optional() })).optional(), "value": z.array(z.object({ "value": z.string(), "weight": z.number(), "name": z.string().optional() })).describe("Support passing values under the value key as that was the original spec for FeatureExperimentRules").optional() })])), "definition": z.string().describe("A JSON stringified [FeatureDefinition](#tag/FeatureDefinition_model)").optional() }).describe("Use to write draft changes without publishing them.").optional() })).describe("A dictionary of environments that are enabled for this feature. Keys supply the names of environments. Environments belong to organization and are not specified will be disabled by default.").optional(), "prerequisites": z.array(z.string()).describe("Feature IDs. Each feature must evaluate to `true`").optional(), "jsonSchema": z.string().describe("Use JSON schema to validate the payload of a JSON-type feature value (enterprise only).").optional(), "customFields": z.record(z.string(), z.string()).optional() }).strict(),
  querySchema: z.never(),
  paramsSchema: z.never(),
};

export const getFeatureValidator = {
  bodySchema: z.never(),
  querySchema: z.object({ "withRevisions": z.enum(["all","drafts","published","none"]).optional() }).strict(),
  paramsSchema: z.object({ "id": z.string() }).strict(),
};

export const updateFeatureValidator = {
  bodySchema: z.object({ "description": z.string().describe("Description of the feature").optional(), "archived": z.boolean().optional(), "project": z.string().describe("An associated project ID").optional(), "owner": z.string().optional(), "defaultValue": z.string().optional(), "tags": z.array(z.string()).describe("List of associated tags. Will override tags completely with submitted list").optional(), "environments": z.record(z.string(), z.object({ "enabled": z.boolean(), "rules": z.array(z.union([z.object({ "description": z.string().optional(), "condition": z.string().describe("Applied to everyone by default.").optional(), "savedGroupTargeting": z.array(z.object({ "matchType": z.enum(["all","any","none"]), "savedGroups": z.array(z.string()) })).optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional(), "id": z.string().optional(), "enabled": z.boolean().describe("Enabled by default").optional(), "type": z.literal("force"), "value": z.string() }), z.object({ "description": z.string().optional(), "condition": z.string().describe("Applied to everyone by default.").optional(), "savedGroupTargeting": z.array(z.object({ "matchType": z.enum(["all","any","none"]), "savedGroups": z.array(z.string()) })).optional(), "prerequisites": z.array(z.object({ "id": z.string().describe("Feature ID"), "condition": z.string() })).optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional(), "id": z.string().optional(), "enabled": z.boolean().describe("Enabled by default").optional(), "type": z.literal("rollout"), "value": z.string(), "coverage": z.number().describe("Percent of traffic included in this experiment. Users not included in the experiment will skip this rule."), "hashAttribute": z.string() }), z.object({ "description": z.string().optional(), "id": z.string().optional(), "enabled": z.boolean().describe("Enabled by default").optional(), "type": z.literal("experiment-ref"), "condition": z.string().optional(), "savedGroupTargeting": z.array(z.object({ "matchType": z.enum(["all","any","none"]), "savedGroups": z.array(z.string()) })).optional(), "prerequisites": z.array(z.object({ "id": z.string().describe("Feature ID"), "condition": z.string() })).optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional(), "variations": z.array(z.object({ "value": z.string(), "variationId": z.string() })), "experimentId": z.string() }), z.object({ "description": z.string().optional(), "condition": z.string(), "id": z.string().optional(), "enabled": z.boolean().describe("Enabled by default").optional(), "type": z.literal("experiment"), "trackingKey": z.string().optional(), "hashAttribute": z.string().optional(), "fallbackAttribute": z.string().optional(), "disableStickyBucketing": z.boolean().optional(), "bucketVersion": z.number().optional(), "minBucketVersion": z.number().optional(), "namespace": z.object({ "enabled": z.boolean(), "name": z.string(), "range": z.array(z.number()).min(2).max(2) }).optional(), "coverage": z.number().optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional(), "values": z.array(z.object({ "value": z.string(), "weight": z.number(), "name": z.string().optional() })).optional(), "value": z.array(z.object({ "value": z.string(), "weight": z.number(), "name": z.string().optional() })).describe("Support passing values under the value key as that was the original spec for FeatureExperimentRules").optional() })])), "definition": z.string().describe("A JSON stringified [FeatureDefinition](#tag/FeatureDefinition_model)").optional(), "draft": z.object({ "enabled": z.boolean().optional(), "rules": z.array(z.union([z.object({ "description": z.string().optional(), "condition": z.string().describe("Applied to everyone by default.").optional(), "savedGroupTargeting": z.array(z.object({ "matchType": z.enum(["all","any","none"]), "savedGroups": z.array(z.string()) })).optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional(), "id": z.string().optional(), "enabled": z.boolean().describe("Enabled by default").optional(), "type": z.literal("force"), "value": z.string() }), z.object({ "description": z.string().optional(), "condition": z.string().describe("Applied to everyone by default.").optional(), "savedGroupTargeting": z.array(z.object({ "matchType": z.enum(["all","any","none"]), "savedGroups": z.array(z.string()) })).optional(), "prerequisites": z.array(z.object({ "id": z.string().describe("Feature ID"), "condition": z.string() })).optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional(), "id": z.string().optional(), "enabled": z.boolean().describe("Enabled by default").optional(), "type": z.literal("rollout"), "value": z.string(), "coverage": z.number().describe("Percent of traffic included in this experiment. Users not included in the experiment will skip this rule."), "hashAttribute": z.string() }), z.object({ "description": z.string().optional(), "id": z.string().optional(), "enabled": z.boolean().describe("Enabled by default").optional(), "type": z.literal("experiment-ref"), "condition": z.string().optional(), "savedGroupTargeting": z.array(z.object({ "matchType": z.enum(["all","any","none"]), "savedGroups": z.array(z.string()) })).optional(), "prerequisites": z.array(z.object({ "id": z.string().describe("Feature ID"), "condition": z.string() })).optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional(), "variations": z.array(z.object({ "value": z.string(), "variationId": z.string() })), "experimentId": z.string() }), z.object({ "description": z.string().optional(), "condition": z.string(), "id": z.string().optional(), "enabled": z.boolean().describe("Enabled by default").optional(), "type": z.literal("experiment"), "trackingKey": z.string().optional(), "hashAttribute": z.string().optional(), "fallbackAttribute": z.string().optional(), "disableStickyBucketing": z.boolean().optional(), "bucketVersion": z.number().optional(), "minBucketVersion": z.number().optional(), "namespace": z.object({ "enabled": z.boolean(), "name": z.string(), "range": z.array(z.number()).min(2).max(2) }).optional(), "coverage": z.number().optional(), "scheduleRules": z.array(z.object({ "enabled": z.boolean().describe("Whether the rule should be enabled or disabled at the specified timestamp."), "timestamp": z.string().nullable().describe("ISO timestamp when the rule should activate.") }).describe("An array of schedule rules to turn on/off a feature rule at specific times. The array must contain exactly 2 elements (start rule and end rule). The first element is the start rule.")).optional(), "values": z.array(z.object({ "value": z.string(), "weight": z.number(), "name": z.string().optional() })).optional(), "value": z.array(z.object({ "value": z.string(), "weight": z.number(), "name": z.string().optional() })).describe("Support passing values under the value key as that was the original spec for FeatureExperimentRules").optional() })])), "definition": z.string().describe("A JSON stringified [FeatureDefinition](#tag/FeatureDefinition_model)").optional() }).describe("Use to write draft changes without publishing them.").optional() })).optional(), "prerequisites": z.array(z.string()).describe("Feature IDs. Each feature must evaluate to `true`").optional(), "jsonSchema": z.string().describe("Use JSON schema to validate the payload of a JSON-type feature value (enterprise only).").optional(), "customFields": z.record(z.string(), z.string()).optional() }).strict(),
  querySchema: z.never(),
  paramsSchema: z.object({ "id": z.string() }).strict(),
};

export const deleteFeatureValidator = {
  bodySchema: z.never(),
  querySchema: z.never(),
  paramsSchema: z.object({ "id": z.string() }).strict(),
};

export const toggleFeatureValidator = {
  bodySchema: z.object({ "reason": z.string().optional(), "environments": z.record(z.string(), z.union([z.literal(true), z.literal(false), z.literal("true"), z.literal("false"), z.literal("1"), z.literal("0"), z.literal(1), z.literal(0), z.literal("")])) }).strict(),
  querySchema: z.never(),
  paramsSchema: z.object({ "id": z.string() }).strict(),
};

export const revertFeatureValidator = {
  bodySchema: z.object({ "revision": z.number(), "comment": z.string().optional() }).strict(),
  querySchema: z.never(),
  paramsSchema: z.object({ "id": z.string() }).strict(),
};

export const getFeatureRevisionsValidator = {
  bodySchema: z.never(),
  querySchema: z.object({ "limit": z.coerce.number().int().default(10), "offset": z.coerce.number().int().default(0) }).strict(),
  paramsSchema: z.object({ "id": z.string() }).strict(),
};

export const getFeatureKeysValidator = {
  bodySchema: z.never(),
  querySchema: z.object({ "projectId": z.string().optional() }).strict(),
  paramsSchema: z.never(),
};

export const listProjectsValidator = {
  bodySchema: z.never(),
  querySchema: z.object({ "limit": z.coerce.number().int().default(10), "offset": z.coerce.number().int().default(0) }).strict(),
  paramsSchema: z.never(),
};

export const postProjectValidator = {
  bodySchema: z.object({ "name": z.string(), "publicId": z.string().describe("Unique identifier for the project. If not provided, the project ID will be used in payloads.").optional(), "description": z.string().optional(), "settings": z.object({ "statsEngine": z.string().describe("Stats engine.").optional() }).describe("Project settings.").optional() }).strict(),
  querySchema: z.never(),
  paramsSchema: z.never(),
};

export const getProjectValidator = {
  bodySchema: z.never(),
  querySchema: z.never(),
  paramsSchema: z.object({ "id": z.string() }).strict(),
};

export const putProjectValidator = {
  bodySchema: z.object({ "name": z.string().describe("Project name.").optional(), "description": z.string().describe("Project description.").optional(), "settings": z.object({ "statsEngine": z.string().describe("Stats engine.").optional() }).describe("Project settings.").optional() }).strict(),
  querySchema: z.never(),
  paramsSchema: z.object({ "id": z.string() }).strict(),
};

export const deleteProjectValidator = {
  bodySchema: z.never(),
  querySchema: z.never(),
  paramsSchema: z.object({ "id": z.string() }).strict(),
};

export const listDimensionsValidator = {
  bodySchema: z.never(),
  querySchema: z.object({ "limit": z.coerce.number().int().default(10), "offset": z.coerce.number().int().default(0), "datasourceId": z.string().optional() }).strict(),
  paramsSchema: z.never(),
};

export const postDimensionValidator = {
  bodySchema: z.object({ "name": z.string().describe("Name of the dimension"), "description": z.string().describe("Description of the dimension").optional(), "owner": z.string().describe("Owner of the dimension").optional(), "datasourceId": z.string().describe("ID of the datasource this dimension belongs to"), "identifierType": z.string().describe("Type of identifier (user, anonymous, etc.)"), "query": z.string().describe("SQL query or equivalent for the dimension"), "managedBy": z.enum(["","api"]).describe("Where this dimension must be managed from. If not set (empty string), it can be managed from anywhere.").optional() }).strict(),
  querySchema: z.never(),
  paramsSchema: z.never(),
};

export const getDimensionValidator = {
  bodySchema: z.never(),
  querySchema: z.never(),
  paramsSchema: z.object({ "id": z.string() }).strict(),
};

export const updateDimensionValidator = {
  bodySchema: z.object({ "name": z.string().describe("Name of the dimension").optional(), "description": z.string().describe("Description of the dimension").optional(), "owner": z.string().describe("Owner of the dimension").optional(), "datasourceId": z.string().describe("ID of the datasource this dimension belongs to").optional(), "identifierType": z.string().describe("Type of identifier (user, anonymous, etc.)").optional(), "query": z.string().describe("SQL query or equivalent for the dimension").optional(), "managedBy": z.enum(["","api"]).describe("Where this dimension must be managed from. If not set (empty string), it can be managed from anywhere.").optional() }).strict(),
  querySchema: z.never(),
  paramsSchema: z.object({ "id": z.string() }).strict(),
};

export const deleteDimensionValidator = {
  bodySchema: z.never(),
  querySchema: z.never(),
  paramsSchema: z.object({ "id": z.string() }).strict(),
};

export const listSegmentsValidator = {
  bodySchema: z.never(),
  querySchema: z.object({ "limit": z.coerce.number().int().default(10), "offset": z.coerce.number().int().default(0), "datasourceId": z.string().optional() }).strict(),
  paramsSchema: z.never(),
};

export const postSegmentValidator = {
  bodySchema: z.object({ "name": z.string().describe("Name of the segment"), "owner": z.string().describe("Owner of the segment").optional(), "description": z.string().describe("Description of the segment").optional(), "datasourceId": z.string().describe("ID of the datasource this segment belongs to"), "identifierType": z.string().describe("Type of identifier (user, anonymous, etc.)"), "projects": z.array(z.string()).describe("List of project IDs for projects that can access this segment").optional(), "managedBy": z.enum(["","api"]).describe("Where this Segment must be managed from. If not set (empty string), it can be managed from anywhere.").optional(), "type": z.enum(["SQL","FACT"]).describe("GrowthBook supports two types of Segments, SQL and FACT. SQL segments are defined by a SQL query, and FACT segments are defined by a fact table and filters."), "query": z.string().describe("SQL query that defines the Segment. This is required for SQL segments.").optional(), "factTableId": z.string().describe("ID of the fact table this segment belongs to. This is required for FACT segments.").optional(), "filters": z.array(z.string()).describe("Optional array of fact table filter ids that can further define the Fact Table based Segment.").optional() }).strict(),
  querySchema: z.never(),
  paramsSchema: z.never(),
};

export const getSegmentValidator = {
  bodySchema: z.never(),
  querySchema: z.never(),
  paramsSchema: z.object({ "id": z.string() }).strict(),
};

export const updateSegmentValidator = {
  bodySchema: z.object({ "name": z.string().describe("Name of the segment").optional(), "description": z.string().describe("Description of the segment").optional(), "owner": z.string().describe("Owner of the segment").optional(), "datasourceId": z.string().describe("ID of the datasource this segment belongs to").optional(), "identifierType": z.string().describe("Type of identifier (user, anonymous, etc.)").optional(), "projects": z.array(z.string()).describe("List of project IDs for projects that can access this segment").optional(), "managedBy": z.enum(["","api"]).describe("Where this Segment must be managed from. If not set (empty string), it can be managed from anywhere.").optional(), "type": z.enum(["SQL","FACT"]).describe("GrowthBook supports two types of Segments, SQL and FACT. SQL segments are defined by a SQL query, and FACT segments are defined by a fact table and filters.").optional(), "query": z.string().describe("SQL query that defines the Segment. This is required for SQL segments.").optional(), "factTableId": z.string().describe("ID of the fact table this segment belongs to. This is required for FACT segments.").optional(), "filters": z.array(z.string()).describe("Optional array of fact table filter ids that can further define the Fact Table based Segment.").optional() }).strict(),
  querySchema: z.never(),
  paramsSchema: z.object({ "id": z.string() }).strict(),
};

export const deleteSegmentValidator = {
  bodySchema: z.never(),
  querySchema: z.never(),
  paramsSchema: z.object({ "id": z.string() }).strict(),
};

export const listSdkConnectionsValidator = {
  bodySchema: z.never(),
  querySchema: z.object({ "limit": z.coerce.number().int().default(10), "offset": z.coerce.number().int().default(0), "projectId": z.string().optional(), "withProxy": z.string().optional(), "multiOrg": z.string().optional() }).strict(),
  paramsSchema: z.never(),
};

export const postSdkConnectionValidator = {
  bodySchema: z.object({ "name": z.string(), "language": z.string(), "sdkVersion": z.string().optional(), "environment": z.string(), "projects": z.array(z.string()).optional(), "encryptPayload": z.boolean().optional(), "includeVisualExperiments": z.boolean().optional(), "includeDraftExperiments": z.boolean().optional(), "includeExperimentNames": z.boolean().optional(), "includeRedirectExperiments": z.boolean().optional(), "includeRuleIds": z.boolean().optional(), "includeProjectPublicId": z.boolean().optional(), "includeCustomFields": z.array(z.string()).optional(), "includeTags": z.boolean().optional(), "proxyEnabled": z.boolean().optional(), "proxyHost": z.string().optional(), "hashSecureAttributes": z.boolean().optional(), "remoteEvalEnabled": z.boolean().optional(), "savedGroupReferencesEnabled": z.boolean().optional() }).strict(),
  querySchema: z.never(),
  paramsSchema: z.never(),
};

export const getSdkConnectionValidator = {
  bodySchema: z.never(),
  querySchema: z.never(),
  paramsSchema: z.object({ "id": z.string() }).strict(),
};

export const putSdkConnectionValidator = {
  bodySchema: z.object({ "name": z.string().optional(), "language": z.string().optional(), "sdkVersion": z.string().optional(), "environment": z.string().optional(), "projects": z.array(z.string()).optional(), "encryptPayload": z.boolean().optional(), "includeVisualExperiments": z.boolean().optional(), "includeDraftExperiments": z.boolean().optional(), "includeExperimentNames": z.boolean().optional(), "includeRedirectExperiments": z.boolean().optional(), "includeRuleIds": z.boolean().optional(), "includeProjectPublicId": z.boolean().optional(), "includeCustomFields": z.array(z.string()).optional(), "includeTags": z.boolean().optional(), "proxyEnabled": z.boolean().optional(), "proxyHost": z.string().optional(), "hashSecureAttributes": z.boolean().optional(), "remoteEvalEnabled": z.boolean().optional(), "savedGroupReferencesEnabled": z.boolean().optional() }).strict(),
  querySchema: z.never(),
  paramsSchema: z.object({ "id": z.string() }).strict(),
};

export const deleteSdkConnectionValidator = {
  bodySchema: z.never(),
  querySchema: z.never(),
  paramsSchema: z.object({ "id": z.string() }).strict(),
};

export const lookupSdkConnectionByKeyValidator = {
  bodySchema: z.never(),
  querySchema: z.never(),
  paramsSchema: z.object({ "key": z.string() }).strict(),
};

export const listDataSourcesValidator = {
  bodySchema: z.never(),
  querySchema: z.object({ "limit": z.coerce.number().int().default(10), "offset": z.coerce.number().int().default(0), "projectId": z.string().optional() }).strict(),
  paramsSchema: z.never(),
};

export const getDataSourceValidator = {
  bodySchema: z.never(),
  querySchema: z.never(),
  paramsSchema: z.object({ "id": z.string() }).strict(),
};

export const listExperimentsValidator = {
  bodySchema: z.never(),
  querySchema: z.object({ "limit": z.coerce.number().int().default(10), "offset": z.coerce.number().int().default(0), "projectId": z.string().optional(), "datasourceId": z.string().optional(), "experimentId": z.string().optional() }).strict(),
  paramsSchema: z.never(),
};

export const postExperimentValidator = {
  bodySchema: z.object({ "datasourceId": z.string().describe("ID for the [DataSource](#tag/DataSource_model)").optional(), "assignmentQueryId": z.string().describe("The ID property of one of the assignment query objects associated with the datasource"), "trackingKey": z.string(), "name": z.string().describe("Name of the experiment"), "type": z.enum(["standard","multi-armed-bandit"]).optional(), "project": z.string().describe("Project ID which the experiment belongs to").optional(), "hypothesis": z.string().describe("Hypothesis of the experiment").optional(), "description": z.string().describe("Description of the experiment").optional(), "tags": z.array(z.string()).optional(), "metrics": z.array(z.string()).optional(), "secondaryMetrics": z.array(z.string()).optional(), "guardrailMetrics": z.array(z.string()).optional(), "activationMetric": z.string().describe("Users must convert on this metric before being included").optional(), "segmentId": z.string().describe("Only users in this segment will be included").optional(), "queryFilter": z.string().describe("WHERE clause to add to the default experiment query").optional(), "owner": z.string().describe("Email of the person who owns this experiment").optional(), "archived": z.boolean().optional(), "status": z.enum(["draft","running","stopped"]).optional(), "autoRefresh": z.boolean().optional(), "hashAttribute": z.string().optional(), "fallbackAttribute": z.string().optional(), "hashVersion": z.union([z.literal(1), z.literal(2)]).optional(), "disableStickyBucketing": z.boolean().optional(), "bucketVersion": z.number().optional(), "minBucketVersion": z.number().optional(), "releasedVariationId": z.string().optional(), "excludeFromPayload": z.boolean().optional(), "inProgressConversions": z.enum(["loose","strict"]).optional(), "attributionModel": z.enum(["firstExposure","experimentDuration"]).describe("Setting attribution model to `\"experimentDuration\"` is the same as selecting \"Ignore Conversion Windows\" for the Conversion Window Override.").optional(), "statsEngine": z.enum(["bayesian","frequentist"]).optional(), "variations": z.array(z.object({ "id": z.string().optional(), "key": z.string(), "name": z.string(), "description": z.string().optional(), "screenshots": z.array(z.object({ "path": z.string(), "width": z.number().optional(), "height": z.number().optional(), "description": z.string().optional() })).optional() })).min(2), "phases": z.array(z.object({ "name": z.string(), "dateStarted": z.string(), "dateEnded": z.string().optional(), "reasonForStopping": z.string().optional(), "seed": z.string().optional(), "coverage": z.number().optional(), "trafficSplit": z.array(z.object({ "variationId": z.string(), "weight": z.number() })).optional(), "namespace": z.object({ "namespaceId": z.string(), "range": z.array(z.number()).min(2).max(2), "enabled": z.boolean().optional() }).optional(), "targetingCondition": z.string().optional(), "prerequisites": z.array(z.object({ "id": z.string().describe("Feature ID"), "condition": z.string() })).optional(), "reason": z.string().optional(), "condition": z.string().optional(), "savedGroupTargeting": z.array(z.object({ "matchType": z.enum(["all","any","none"]), "savedGroups": z.array(z.string()) })).optional(), "variationWeights": z.array(z.number()).optional() })).optional(), "regressionAdjustmentEnabled": z.boolean().describe("Controls whether regression adjustment (CUPED) is enabled for experiment analyses").optional(), "sequentialTestingEnabled": z.boolean().describe("Only applicable to frequentist analyses").optional(), "sequentialTestingTuningParameter": z.number().optional(), "shareLevel": z.enum(["public","organization"]).optional(), "banditScheduleValue": z.number().optional(), "banditScheduleUnit": z.enum(["days","hours"]).optional(), "banditBurnInValue": z.number().optional(), "banditBurnInUnit": z.enum(["days","hours"]).optional(), "customFields": z.record(z.string(), z.string()).optional(), "pinnedMetricSlices": z.array(z.string()).describe("Array of pinned metric slices in format `{metricId}?dim:{sliceColumn}={sliceLevel}&location={goal|secondary|guardrail}` (URL-encoded)").optional(), "customMetricSlices": z.array(z.object({ "slices": z.array(z.object({ "column": z.string(), "levels": z.array(z.string()) })) })).describe("Custom slices that apply to ALL applicable metrics in the experiment").optional() }).strict(),
  querySchema: z.never(),
  paramsSchema: z.never(),
};

export const getExperimentNamesValidator = {
  bodySchema: z.never(),
  querySchema: z.object({ "projectId": z.string().optional() }).strict(),
  paramsSchema: z.never(),
};

export const getExperimentValidator = {
  bodySchema: z.never(),
  querySchema: z.never(),
  paramsSchema: z.object({ "id": z.string() }).strict(),
};

export const updateExperimentValidator = {
  bodySchema: z.object({ "datasourceId": z.string().describe("Can only be set if existing experiment does not have a datasource").optional(), "assignmentQueryId": z.string().optional(), "trackingKey": z.string().optional(), "name": z.string().describe("Name of the experiment").optional(), "type": z.enum(["standard","multi-armed-bandit"]).optional(), "project": z.string().describe("Project ID which the experiment belongs to").optional(), "hypothesis": z.string().describe("Hypothesis of the experiment").optional(), "description": z.string().describe("Description of the experiment").optional(), "tags": z.array(z.string()).optional(), "metrics": z.array(z.string()).optional(), "secondaryMetrics": z.array(z.string()).optional(), "guardrailMetrics": z.array(z.string()).optional(), "activationMetric": z.string().describe("Users must convert on this metric before being included").optional(), "segmentId": z.string().describe("Only users in this segment will be included").optional(), "queryFilter": z.string().describe("WHERE clause to add to the default experiment query").optional(), "owner": z.string().describe("Email of the person who owns this experiment").optional(), "archived": z.boolean().optional(), "status": z.enum(["draft","running","stopped"]).optional(), "autoRefresh": z.boolean().optional(), "hashAttribute": z.string().optional(), "fallbackAttribute": z.string().optional(), "hashVersion": z.union([z.literal(1), z.literal(2)]).optional(), "disableStickyBucketing": z.boolean().optional(), "bucketVersion": z.number().optional(), "minBucketVersion": z.number().optional(), "releasedVariationId": z.string().optional(), "excludeFromPayload": z.boolean().optional(), "inProgressConversions": z.enum(["loose","strict"]).optional(), "attributionModel": z.enum(["firstExposure","experimentDuration"]).describe("Setting attribution model to `\"experimentDuration\"` is the same as selecting \"Ignore Conversion Windows\" for the Conversion Window Override.").optional(), "statsEngine": z.enum(["bayesian","frequentist"]).optional(), "variations": z.array(z.object({ "id": z.string().optional(), "key": z.string(), "name": z.string(), "description": z.string().optional(), "screenshots": z.array(z.object({ "path": z.string(), "width": z.number().optional(), "height": z.number().optional(), "description": z.string().optional() })).optional() })).min(2).optional(), "phases": z.array(z.object({ "name": z.string(), "dateStarted": z.string(), "dateEnded": z.string().optional(), "reasonForStopping": z.string().optional(), "seed": z.string().optional(), "coverage": z.number().optional(), "trafficSplit": z.array(z.object({ "variationId": z.string(), "weight": z.number() })).optional(), "namespace": z.object({ "namespaceId": z.string(), "range": z.array(z.number()).min(2).max(2), "enabled": z.boolean().optional() }).optional(), "targetingCondition": z.string().optional(), "prerequisites": z.array(z.object({ "id": z.string().describe("Feature ID"), "condition": z.string() })).optional(), "reason": z.string().optional(), "condition": z.string().optional(), "savedGroupTargeting": z.array(z.object({ "matchType": z.enum(["all","any","none"]), "savedGroups": z.array(z.string()) })).optional(), "variationWeights": z.array(z.number()).optional() })).optional(), "regressionAdjustmentEnabled": z.boolean().describe("Controls whether regression adjustment (CUPED) is enabled for experiment analyses").optional(), "sequentialTestingEnabled": z.boolean().describe("Only applicable to frequentist analyses").optional(), "sequentialTestingTuningParameter": z.number().optional(), "shareLevel": z.enum(["public","organization"]).optional(), "banditScheduleValue": z.number().optional(), "banditScheduleUnit": z.enum(["days","hours"]).optional(), "banditBurnInValue": z.number().optional(), "banditBurnInUnit": z.enum(["days","hours"]).optional(), "customFields": z.record(z.string(), z.string()).optional(), "pinnedMetricSlices": z.array(z.string()).describe("Array of pinned metric slices in format `{metricId}?dim:{sliceColumn}={sliceLevel}&location={goal|secondary|guardrail}` (URL-encoded)").optional(), "customMetricSlices": z.array(z.object({ "slices": z.array(z.object({ "column": z.string(), "levels": z.array(z.string()) })) })).describe("Custom slices that apply to ALL applicable metrics in the experiment").optional() }).strict(),
  querySchema: z.never(),
  paramsSchema: z.object({ "id": z.string() }).strict(),
};

export const postExperimentSnapshotValidator = {
  bodySchema: z.object({ "triggeredBy": z.enum(["manual","schedule"]).describe("Set to \"schedule\" if you want this request to trigger notifications and other events as it if were a scheduled update. Defaults to manual.").optional() }).strict(),
  querySchema: z.never(),
  paramsSchema: z.object({ "id": z.string() }).strict(),
};

export const getExperimentResultsValidator = {
  bodySchema: z.never(),
  querySchema: z.object({ "phase": z.string().optional(), "dimension": z.string().optional() }).strict(),
  paramsSchema: z.object({ "id": z.string() }).strict(),
};

export const listVisualChangesetsValidator = {
  bodySchema: z.never(),
  querySchema: z.never(),
  paramsSchema: z.object({ "id": z.string() }).strict(),
};

export const getExperimentSnapshotValidator = {
  bodySchema: z.never(),
  querySchema: z.never(),
  paramsSchema: z.object({ "id": z.string() }).strict(),
};

export const listMetricsValidator = {
  bodySchema: z.never(),
  querySchema: z.object({ "limit": z.coerce.number().int().default(10), "offset": z.coerce.number().int().default(0), "projectId": z.string().optional(), "datasourceId": z.string().optional() }).strict(),
  paramsSchema: z.never(),
};

export const postMetricValidator = {
  bodySchema: z.object({ "datasourceId": z.string().describe("ID for the [DataSource](#tag/DataSource_model)"), "managedBy": z.enum(["","api"]).describe("Where this metric must be managed from. If not set (empty string), it can be managed from anywhere. If set to \"api\", it can be managed via the API only.").optional(), "owner": z.string().describe("Name of the person who owns this metric").optional(), "name": z.string().describe("Name of the metric"), "description": z.string().describe("Description of the metric").optional(), "type": z.enum(["binomial","count","duration","revenue"]).describe("Type of metric. See [Metrics documentation](/app/metrics/legacy)"), "tags": z.array(z.string()).describe("List of tags").optional(), "projects": z.array(z.string()).describe("List of project IDs for projects that can access this metric").optional(), "archived": z.boolean().optional(), "behavior": z.object({ "goal": z.enum(["increase","decrease"]).optional(), "cappingSettings": z.object({ "type": z.enum(["none","absolute","percentile"]).nullable(), "value": z.number().describe("When type is absolute, this is the absolute value. When type is percentile, this is the percentile value (from 0.0 to 1.0).").optional(), "ignoreZeros": z.boolean().describe("If true and capping is `percentile`, zeros will be ignored when calculating the percentile.").optional() }).describe("Controls how outliers are handled").optional(), "cap": z.number().gte(0).describe("(deprecated, use cappingSettings instead) This should be non-negative").optional(), "capping": z.enum(["absolute","percentile"]).nullable().describe("(deprecated, use cappingSettings instead) Used in conjunction with `capValue` to set the capping (winsorization). Do not specify or set to null for no capping. \"absolute\" will cap user values at the `capValue` if it is greater than 0. \"percentile\" will cap user values at the percentile of user values in an experiment using the `capValue` for the percentile, if greater than 0. <br/>  If `behavior.capping` is non-null, you must specify `behavior.capValue`.").optional(), "capValue": z.number().gte(0).describe("(deprecated, use cappingSettings instead) This should be non-negative. <br/> Must specify `behavior.capping` when setting `behavior.capValue`.").optional(), "windowSettings": z.object({ "type": z.enum(["none","conversion","lookback"]), "delayHours": z.number().describe("Wait this many hours after experiment exposure before counting conversions. Ignored if delayValue is set.").optional(), "delayValue": z.number().describe("Wait this long after experiment exposure before counting conversions.").optional(), "delayUnit": z.enum(["minutes","hours","days","weeks"]).describe("Default `hours`.").optional(), "windowValue": z.number().optional(), "windowUnit": z.enum(["minutes","hours","days","weeks"]).optional() }).describe("Controls the conversion window for the metric").optional(), "conversionWindowStart": z.number().describe("The start of a Conversion Window relative to the exposure date, in hours. This is equivalent to the [Conversion Delay](/app/metrics/legacy/#conversion-delay). <br/> Must specify both `behavior.conversionWindowStart` and `behavior.conversionWindowEnd` or neither.").optional(), "conversionWindowEnd": z.number().describe("The end of a [Conversion Window](/app/metrics/legacy/#conversion-window) relative to the exposure date, in hours. This is equivalent to the [Conversion Delay](/app/metrics/legacy/#conversion-delay) + Conversion Window Hours settings in the UI. In other words, if you want a 48 hour window starting after 24 hours, you would set conversionWindowStart to 24 and conversionWindowEnd to 72 (24+48). <br/> Must specify both `behavior.conversionWindowStart` and `behavior.conversionWindowEnd` or neither.").optional(), "priorSettings": z.object({ "override": z.boolean().describe("If false, the organization default settings will be used instead of the other settings in this object"), "proper": z.boolean().describe("If true, the `mean` and `stddev` will be used, otherwise we will use an improper flat prior."), "mean": z.number().describe("The mean of the prior distribution of relative effects in proportion terms (e.g. 0.01 is 1%)"), "stddev": z.number().gt(0).describe("Must be > 0. The standard deviation of the prior distribution of relative effects in proportion terms.") }).describe("Controls the bayesian prior for the metric. If omitted, organization defaults will be used.").optional(), "riskThresholdSuccess": z.number().gte(0).describe("Threshold for Risk to be considered low enough, as a proportion (e.g. put 0.0025 for 0.25%). <br/> Must be a non-negative number and must not be higher than `riskThresholdDanger`.").optional(), "riskThresholdDanger": z.number().gte(0).describe("Threshold for Risk to be considered too high, as a proportion (e.g. put 0.0125 for 1.25%). <br/> Must be a non-negative number.").optional(), "minPercentChange": z.number().gte(0).describe("Minimum percent change to consider uplift significant, as a proportion (e.g. put 0.005 for 0.5%)").optional(), "maxPercentChange": z.number().gte(0).describe("Maximum percent change to consider uplift significant, as a proportion (e.g. put 0.5 for 50%)").optional(), "minSampleSize": z.number().gte(0).optional(), "targetMDE": z.number().gte(0).describe("The percentage change that you want to reliably detect before ending an experiment, as a proportion (e.g. put 0.1 for 10%). This is used to estimate the \"Days Left\" for running experiments.").optional() }).optional(), "sql": z.object({ "identifierTypes": z.array(z.string()), "conversionSQL": z.string(), "userAggregationSQL": z.string().describe("Custom user level aggregation for your metric (default: `SUM(value)`)").optional(), "denominatorMetricId": z.string().describe("The metric ID for a [denominator metric for funnel and ratio metrics](/app/metrics/legacy/#denominator-ratio--funnel-metrics)").optional() }).describe("Preferred way to define SQL. Only one of `sql`, `sqlBuilder` or `mixpanel` allowed, and at least one must be specified.").optional(), "sqlBuilder": z.object({ "identifierTypeColumns": z.array(z.object({ "identifierType": z.string(), "columnName": z.string() })), "tableName": z.string(), "valueColumnName": z.string().optional(), "timestampColumnName": z.string(), "conditions": z.array(z.object({ "column": z.string(), "operator": z.string(), "value": z.string() })).optional() }).describe("An alternative way to specify a SQL metric, rather than a full query. Using `sql` is preferred to `sqlBuilder`. Only one of `sql`, `sqlBuilder` or `mixpanel` allowed, and at least one must be specified.").optional(), "mixpanel": z.object({ "eventName": z.string(), "eventValue": z.string().optional(), "userAggregation": z.string(), "conditions": z.array(z.object({ "property": z.string(), "operator": z.string(), "value": z.string() })).optional() }).describe("Only use for MixPanel (non-SQL) Data Sources. Only one of `sql`, `sqlBuilder` or `mixpanel` allowed, and at least one must be specified.").optional() }).strict(),
  querySchema: z.never(),
  paramsSchema: z.never(),
};

export const getMetricValidator = {
  bodySchema: z.never(),
  querySchema: z.never(),
  paramsSchema: z.object({ "id": z.string() }).strict(),
};

export const putMetricValidator = {
  bodySchema: z.object({ "managedBy": z.enum(["","api","admin"]).describe("Where this metric must be managed from. If not set (empty string), it can be managed from anywhere. If set to \"api\", it can be managed via the API only. Please note that we have deprecated support for setting the managedBy property to \"admin\". Your existing Legacy Metrics with this value will continue to work, but we suggest migrating to Fact Metrics instead.").optional(), "owner": z.string().describe("Name of the person who owns this metric").optional(), "name": z.string().describe("Name of the metric").optional(), "description": z.string().describe("Description of the metric").optional(), "type": z.enum(["binomial","count","duration","revenue"]).describe("Type of metric. See [Metrics documentation](/app/metrics/legacy)").optional(), "tags": z.array(z.string()).describe("List of tags").optional(), "projects": z.array(z.string()).describe("List of project IDs for projects that can access this metric").optional(), "archived": z.boolean().optional(), "behavior": z.object({ "goal": z.enum(["increase","decrease"]).optional(), "cappingSettings": z.object({ "type": z.enum(["none","absolute","percentile"]).nullable(), "value": z.number().describe("When type is absolute, this is the absolute value. When type is percentile, this is the percentile value (from 0.0 to 1.0).").optional(), "ignoreZeros": z.boolean().describe("If true and capping is `percentile`, zeros will be ignored when calculating the percentile.").optional() }).describe("Controls how outliers are handled").optional(), "cap": z.number().gte(0).describe("(deprecated, use cappingSettings instead) This should be non-negative").optional(), "capping": z.enum(["absolute","percentile"]).nullable().describe("(deprecated, use cappingSettings instead) Used in conjunction with `capValue` to set the capping (winsorization). Do not specify or set to null for no capping. \"absolute\" will cap user values at the `capValue` if it is greater than 0. \"percentile\" will cap user values at the percentile of user values in an experiment using the `capValue` for the percentile, if greater than 0. <br/>  If `behavior.capping` is non-null, you must specify `behavior.capValue`.").optional(), "capValue": z.number().gte(0).describe("(deprecated, use cappingSettings instead) This should be non-negative. <br/> Must specify `behavior.capping` when setting `behavior.capValue`.").optional(), "windowSettings": z.object({ "type": z.enum(["none","conversion","lookback"]), "delayHours": z.number().describe("Wait this many hours after experiment exposure before counting conversions. Ignored if delayValue is set.").optional(), "delayValue": z.number().describe("Wait this long after experiment exposure before counting conversions.").optional(), "delayUnit": z.enum(["minutes","hours","days","weeks"]).describe("Default `hours`.").optional(), "windowValue": z.number().optional(), "windowUnit": z.enum(["minutes","hours","days","weeks"]).optional() }).describe("Controls the conversion window for the metric").optional(), "conversionWindowStart": z.number().describe("The start of a Conversion Window relative to the exposure date, in hours. This is equivalent to the [Conversion Delay](/app/metrics/legacy/#conversion-delay). <br/> Must specify both `behavior.conversionWindowStart` and `behavior.conversionWindowEnd` or neither.").optional(), "conversionWindowEnd": z.number().describe("The end of a [Conversion Window](/app/metrics/legacy/#conversion-window) relative to the exposure date, in hours. This is equivalent to the [Conversion Delay](/app/metrics/legacy/#conversion-delay) + Conversion Window Hours settings in the UI. In other words, if you want a 48 hour window starting after 24 hours, you would set conversionWindowStart to 24 and conversionWindowEnd to 72 (24+48). <br/> Must specify both `behavior.conversionWindowStart` and `behavior.conversionWindowEnd` or neither.").optional(), "priorSettings": z.object({ "override": z.boolean().describe("If false, the organization default settings will be used instead of the other settings in this object"), "proper": z.boolean().describe("If true, the `mean` and `stddev` will be used, otherwise we will use an improper flat prior."), "mean": z.number().describe("The mean of the prior distribution of relative effects in proportion terms (e.g. 0.01 is 1%)"), "stddev": z.number().gt(0).describe("Must be > 0. The standard deviation of the prior distribution of relative effects in proportion terms.") }).describe("Controls the bayesian prior for the metric. If omitted, organization defaults will be used.").optional(), "riskThresholdSuccess": z.number().gte(0).describe("Threshold for Risk to be considered low enough, as a proportion (e.g. put 0.0025 for 0.25%). <br/> Must be a non-negative number and must not be higher than `riskThresholdDanger`.").optional(), "riskThresholdDanger": z.number().gte(0).describe("Threshold for Risk to be considered too high, as a proportion (e.g. put 0.0125 for 1.25%). <br/> Must be a non-negative number.").optional(), "minPercentChange": z.number().gte(0).describe("Minimum percent change to consider uplift significant, as a proportion (e.g. put 0.005 for 0.5%)").optional(), "maxPercentChange": z.number().gte(0).describe("Maximum percent change to consider uplift significant, as a proportion (e.g. put 0.5 for 50%)").optional(), "minSampleSize": z.number().gte(0).optional(), "targetMDE": z.number().gte(0).describe("The percentage change that you want to reliably detect before ending an experiment, as a proportion (e.g. put 0.1 for 10%). This is used to estimate the \"Days Left\" for running experiments.").optional() }).optional(), "sql": z.object({ "identifierTypes": z.array(z.string()).optional(), "conversionSQL": z.string().optional(), "userAggregationSQL": z.string().describe("Custom user level aggregation for your metric (default: `SUM(value)`)").optional(), "denominatorMetricId": z.string().describe("The metric ID for a [denominator metric for funnel and ratio metrics](/app/metrics/legacy/#denominator-ratio--funnel-metrics)").optional() }).describe("Preferred way to define SQL. Only one of `sql`, `sqlBuilder` or `mixpanel` allowed.").optional(), "sqlBuilder": z.object({ "identifierTypeColumns": z.array(z.object({ "identifierType": z.string(), "columnName": z.string() })).optional(), "tableName": z.string().optional(), "valueColumnName": z.string().optional(), "timestampColumnName": z.string().optional(), "conditions": z.array(z.object({ "column": z.string(), "operator": z.string(), "value": z.string() })).optional() }).describe("An alternative way to specify a SQL metric, rather than a full query. Using `sql` is preferred to `sqlBuilder`. Only one of `sql`, `sqlBuilder` or `mixpanel` allowed").optional(), "mixpanel": z.object({ "eventName": z.string().optional(), "eventValue": z.string().optional(), "userAggregation": z.string().optional(), "conditions": z.array(z.object({ "property": z.string(), "operator": z.string(), "value": z.string() })).optional() }).describe("Only use for MixPanel (non-SQL) Data Sources. Only one of `sql`, `sqlBuilder` or `mixpanel` allowed.").optional() }).strict(),
  querySchema: z.never(),
  paramsSchema: z.object({ "id": z.string() }).strict(),
};

export const deleteMetricValidator = {
  bodySchema: z.never(),
  querySchema: z.never(),
  paramsSchema: z.object({ "id": z.string() }).strict(),
};

export const getVisualChangesetValidator = {
  bodySchema: z.never(),
  querySchema: z.object({ "includeExperiment": z.coerce.number().int().optional() }).strict(),
  paramsSchema: z.object({ "id": z.string() }).strict(),
};

export const putVisualChangesetValidator = {
  bodySchema: z.never(),
  querySchema: z.never(),
  paramsSchema: z.object({ "id": z.string() }).strict(),
};

export const postVisualChangeValidator = {
  bodySchema: z.never(),
  querySchema: z.never(),
  paramsSchema: z.object({ "id": z.string() }).strict(),
};

export const putVisualChangeValidator = {
  bodySchema: z.never(),
  querySchema: z.never(),
  paramsSchema: z.object({ "id": z.string(), "visualChangeId": z.string() }).strict(),
};

export const listSavedGroupsValidator = {
  bodySchema: z.never(),
  querySchema: z.object({ "limit": z.coerce.number().int().default(10), "offset": z.coerce.number().int().default(0) }).strict(),
  paramsSchema: z.never(),
};

export const postSavedGroupValidator = {
  bodySchema: z.object({ "name": z.string().describe("The display name of the Saved Group"), "type": z.enum(["condition","list"]).describe("The type of Saved Group (inferred from other arguments if missing)").optional(), "condition": z.string().describe("When type = 'condition', this is the JSON-encoded condition for the group").optional(), "attributeKey": z.string().describe("When type = 'list', this is the attribute key the group is based on").optional(), "values": z.array(z.string()).describe("When type = 'list', this is the list of values for the attribute key").optional(), "owner": z.string().describe("The person or team that owns this Saved Group. If no owner, you can pass an empty string.").optional(), "projects": z.array(z.string()).optional() }).strict(),
  querySchema: z.never(),
  paramsSchema: z.never(),
};

export const getSavedGroupValidator = {
  bodySchema: z.never(),
  querySchema: z.never(),
  paramsSchema: z.object({ "id": z.string() }).strict(),
};

export const updateSavedGroupValidator = {
  bodySchema: z.object({ "name": z.string().describe("The display name of the Saved Group").optional(), "condition": z.string().describe("When type = 'condition', this is the JSON-encoded condition for the group").optional(), "values": z.array(z.string()).describe("When type = 'list', this is the list of values for the attribute key").optional(), "owner": z.string().describe("The person or team that owns this Saved Group. If no owner, you can pass an empty string.").optional(), "projects": z.array(z.string()).optional() }).strict(),
  querySchema: z.never(),
  paramsSchema: z.object({ "id": z.string() }).strict(),
};

export const deleteSavedGroupValidator = {
  bodySchema: z.never(),
  querySchema: z.never(),
  paramsSchema: z.object({ "id": z.string() }).strict(),
};

export const listOrganizationsValidator = {
  bodySchema: z.never(),
  querySchema: z.object({ "search": z.string().optional(), "limit": z.coerce.number().int().default(10), "offset": z.coerce.number().int().default(0) }).strict(),
  paramsSchema: z.never(),
};

export const postOrganizationValidator = {
  bodySchema: z.object({ "name": z.string().describe("The name of the organization"), "externalId": z.string().describe("An optional identifier that you use within your company for the organization").optional() }).strict(),
  querySchema: z.never(),
  paramsSchema: z.never(),
};

export const putOrganizationValidator = {
  bodySchema: z.object({ "name": z.string().describe("The name of the organization").optional(), "externalId": z.string().describe("An optional identifier that you use within your company for the organization").optional() }).strict(),
  querySchema: z.never(),
  paramsSchema: z.object({ "id": z.string() }).strict(),
};

export const listAttributesValidator = {
  bodySchema: z.never(),
  querySchema: z.never(),
  paramsSchema: z.never(),
};

export const postAttributeValidator = {
  bodySchema: z.object({ "property": z.string().describe("The attribute property"), "datatype": z.enum(["boolean","string","number","secureString","enum","string[]","number[]","secureString[]"]).describe("The attribute datatype"), "description": z.string().describe("The description of the new attribute").optional(), "archived": z.boolean().describe("The attribute is archived").optional(), "hashAttribute": z.boolean().describe("Shall the attribute be hashed").optional(), "enum": z.string().optional(), "format": z.enum(["","version","date","isoCountryCode"]).describe("The attribute's format").optional(), "projects": z.array(z.string()).optional() }).strict(),
  querySchema: z.never(),
  paramsSchema: z.never(),
};

export const putAttributeValidator = {
  bodySchema: z.object({ "datatype": z.enum(["boolean","string","number","secureString","enum","string[]","number[]","secureString[]"]).describe("The attribute datatype").optional(), "description": z.string().describe("The description of the new attribute").optional(), "archived": z.boolean().describe("The attribute is archived").optional(), "hashAttribute": z.boolean().describe("Shall the attribute be hashed").optional(), "enum": z.string().optional(), "format": z.enum(["","version","date","isoCountryCode"]).describe("The attribute's format").optional(), "projects": z.array(z.string()).optional() }).strict(),
  querySchema: z.never(),
  paramsSchema: z.object({ "property": z.string() }).strict(),
};

export const deleteAttributeValidator = {
  bodySchema: z.never(),
  querySchema: z.never(),
  paramsSchema: z.object({ "property": z.string() }).strict(),
};

export const listArchetypesValidator = {
  bodySchema: z.never(),
  querySchema: z.never(),
  paramsSchema: z.never(),
};

export const postArchetypeValidator = {
  bodySchema: z.object({ "name": z.string(), "description": z.string().optional(), "isPublic": z.boolean().describe("Whether to make this Archetype available to other team members"), "attributes": z.record(z.string(), z.any()).describe("The attributes to set when using this Archetype").optional(), "projects": z.array(z.string()).optional() }).strict(),
  querySchema: z.never(),
  paramsSchema: z.never(),
};

export const getArchetypeValidator = {
  bodySchema: z.never(),
  querySchema: z.never(),
  paramsSchema: z.object({ "id": z.string() }).strict(),
};

export const putArchetypeValidator = {
  bodySchema: z.object({ "name": z.string().optional(), "description": z.string().optional(), "isPublic": z.boolean().describe("Whether to make this Archetype available to other team members").optional(), "attributes": z.record(z.string(), z.any()).describe("The attributes to set when using this Archetype").optional(), "projects": z.array(z.string()).optional() }).strict(),
  querySchema: z.never(),
  paramsSchema: z.object({ "id": z.string() }).strict(),
};

export const deleteArchetypeValidator = {
  bodySchema: z.never(),
  querySchema: z.never(),
  paramsSchema: z.object({ "id": z.string() }).strict(),
};

export const listMembersValidator = {
  bodySchema: z.never(),
  querySchema: z.object({ "limit": z.coerce.number().int().default(10), "offset": z.coerce.number().int().default(0), "userName": z.string().optional(), "userEmail": z.string().optional(), "globalRole": z.string().optional() }).strict(),
  paramsSchema: z.never(),
};

export const deleteMemberValidator = {
  bodySchema: z.never(),
  querySchema: z.never(),
  paramsSchema: z.object({ "id": z.string() }).strict(),
};

export const updateMemberRoleValidator = {
  bodySchema: z.object({ "member": z.object({ "role": z.string().optional(), "environments": z.array(z.string()).optional(), "projectRoles": z.array(z.object({ "project": z.string(), "role": z.string(), "environments": z.array(z.string()), "limitAccessByEnvironment": z.boolean().optional() })).optional() }) }).strict(),
  querySchema: z.never(),
  paramsSchema: z.object({ "id": z.string() }).strict(),
};

export const listEnvironmentsValidator = {
  bodySchema: z.never(),
  querySchema: z.never(),
  paramsSchema: z.never(),
};

export const postEnvironmentValidator = {
  bodySchema: z.object({ "id": z.string().describe("The ID of the new environment"), "description": z.string().describe("The description of the new environment").optional(), "toggleOnList": z.any().describe("Show toggle on feature list").optional(), "defaultState": z.any().describe("Default state for new features").optional(), "projects": z.array(z.string()).optional(), "parent": z.string().describe("An environment that the new environment should inherit feature rules from. Requires an enterprise license").optional() }).strict(),
  querySchema: z.never(),
  paramsSchema: z.never(),
};

export const putEnvironmentValidator = {
  bodySchema: z.object({ "description": z.string().describe("The description of the new environment").optional(), "toggleOnList": z.boolean().describe("Show toggle on feature list").optional(), "defaultState": z.boolean().describe("Default state for new features").optional(), "projects": z.array(z.string()).optional() }).strict(),
  querySchema: z.never(),
  paramsSchema: z.object({ "id": z.string() }).strict(),
};

export const deleteEnvironmentValidator = {
  bodySchema: z.never(),
  querySchema: z.never(),
  paramsSchema: z.object({ "id": z.string() }).strict(),
};

export const listFactTablesValidator = {
  bodySchema: z.never(),
  querySchema: z.object({ "limit": z.coerce.number().int().default(10), "offset": z.coerce.number().int().default(0), "datasourceId": z.string().optional(), "projectId": z.string().optional() }).strict(),
  paramsSchema: z.never(),
};

export const postFactTableValidator = {
  bodySchema: z.object({ "name": z.string(), "description": z.string().describe("Description of the fact table").optional(), "owner": z.string().describe("The person who is responsible for this fact table").optional(), "projects": z.array(z.string()).describe("List of associated project ids").optional(), "tags": z.array(z.string()).describe("List of associated tags").optional(), "datasource": z.string().describe("The datasource id"), "userIdTypes": z.array(z.string()).describe("List of identifier columns in this table. For example, \"id\" or \"anonymous_id\""), "sql": z.string().describe("The SQL query for this fact table"), "eventName": z.string().describe("The event name used in SQL template variables").optional(), "managedBy": z.enum(["","api","admin"]).describe("Set this to \"api\" to disable editing in the GrowthBook UI").optional() }).strict(),
  querySchema: z.never(),
  paramsSchema: z.never(),
};

export const getFactTableValidator = {
  bodySchema: z.never(),
  querySchema: z.never(),
  paramsSchema: z.object({ "id": z.string() }).strict(),
};

export const updateFactTableValidator = {
  bodySchema: z.object({ "name": z.string().optional(), "description": z.string().describe("Description of the fact table").optional(), "owner": z.string().describe("The person who is responsible for this fact table").optional(), "projects": z.array(z.string()).describe("List of associated project ids").optional(), "tags": z.array(z.string()).describe("List of associated tags").optional(), "userIdTypes": z.array(z.string()).describe("List of identifier columns in this table. For example, \"id\" or \"anonymous_id\"").optional(), "sql": z.string().describe("The SQL query for this fact table").optional(), "eventName": z.string().describe("The event name used in SQL template variables").optional(), "columns": z.array(z.object({ "column": z.string().describe("The actual column name in the database/SQL query"), "datatype": z.enum(["number","string","date","boolean","json","other",""]), "numberFormat": z.enum(["","currency","time:seconds","memory:bytes","memory:kilobytes"]).optional(), "jsonFields": z.record(z.string(), z.object({ "datatype": z.enum(["number","string","date","boolean","json","other",""]).optional() })).describe("For JSON columns, defines the structure of nested fields").optional(), "name": z.string().describe("Display name for the column (can be different from the actual column name)").optional(), "description": z.string().optional(), "alwaysInlineFilter": z.boolean().describe("Whether this column should always be included as an inline filter in queries").default(false), "deleted": z.boolean().default(false), "isAutoSliceColumn": z.boolean().describe("Whether this column can be used for auto slice analysis. This is an enterprise feature.").default(false), "autoSlices": z.array(z.string()).describe("Specific slices to automatically analyze for this column.").optional(), "dateCreated": z.string().readonly().optional(), "dateUpdated": z.string().readonly().optional() })).describe("Optional array of columns that you want to update. Only allows updating properties of existing columns. Cannot create new columns or delete existing ones. Columns cannot be added or deleted; column structure is determined by SQL parsing. Slice-related properties require an enterprise license.").optional(), "columnsError": z.string().nullable().describe("Error message if there was an issue parsing the SQL schema").optional(), "managedBy": z.enum(["","api","admin"]).describe("Set this to \"api\" to disable editing in the GrowthBook UI").optional(), "archived": z.boolean().optional() }).strict(),
  querySchema: z.never(),
  paramsSchema: z.object({ "id": z.string() }).strict(),
};

export const deleteFactTableValidator = {
  bodySchema: z.never(),
  querySchema: z.never(),
  paramsSchema: z.object({ "id": z.string() }).strict(),
};

export const listFactTableFiltersValidator = {
  bodySchema: z.never(),
  querySchema: z.object({ "limit": z.coerce.number().int().default(10), "offset": z.coerce.number().int().default(0) }).strict(),
  paramsSchema: z.object({ "factTableId": z.string() }).strict(),
};

export const postFactTableFilterValidator = {
  bodySchema: z.object({ "name": z.string(), "description": z.string().describe("Description of the fact table filter").optional(), "value": z.string().describe("The SQL expression for this filter."), "managedBy": z.enum(["","api"]).describe("Set this to \"api\" to disable editing in the GrowthBook UI. Before you do this, the Fact Table itself must also be marked as \"api\"").optional() }).strict(),
  querySchema: z.never(),
  paramsSchema: z.object({ "factTableId": z.string() }).strict(),
};

export const getFactTableFilterValidator = {
  bodySchema: z.never(),
  querySchema: z.never(),
  paramsSchema: z.object({ "factTableId": z.string(), "id": z.string() }).strict(),
};

export const updateFactTableFilterValidator = {
  bodySchema: z.object({ "name": z.string().optional(), "description": z.string().describe("Description of the fact table filter").optional(), "value": z.string().describe("The SQL expression for this filter.").optional(), "managedBy": z.enum(["","api"]).describe("Set this to \"api\" to disable editing in the GrowthBook UI. Before you do this, the Fact Table itself must also be marked as \"api\"").optional() }).strict(),
  querySchema: z.never(),
  paramsSchema: z.object({ "factTableId": z.string(), "id": z.string() }).strict(),
};

export const deleteFactTableFilterValidator = {
  bodySchema: z.never(),
  querySchema: z.never(),
  paramsSchema: z.object({ "factTableId": z.string(), "id": z.string() }).strict(),
};

export const listFactMetricsValidator = {
  bodySchema: z.never(),
  querySchema: z.object({ "limit": z.coerce.number().int().default(10), "offset": z.coerce.number().int().default(0), "datasourceId": z.string().optional(), "projectId": z.string().optional(), "factTableId": z.string().optional() }).strict(),
  paramsSchema: z.never(),
};

export const postFactMetricValidator = {
  bodySchema: z.object({ "name": z.string(), "description": z.string().optional(), "owner": z.string().optional(), "projects": z.array(z.string()).optional(), "tags": z.array(z.string()).optional(), "metricType": z.enum(["proportion","retention","mean","quantile","ratio","dailyParticipation"]), "numerator": z.object({ "factTableId": z.string(), "column": z.string().describe("Must be empty for proportion metrics and dailyParticipation metrics. Otherwise, the column name or one of the special values: '$$distinctUsers' or '$$count' (or '$$distinctDates' if metricType is 'mean' or 'ratio' or 'quantile' and quantileSettings.type is 'unit')").optional(), "aggregation": z.enum(["sum","max","count distinct"]).describe("User aggregation of selected column. Either sum or max for numeric columns; count distinct for string columns; ignored for special columns. Default: sum. If you specify a string column you must explicitly specify count distinct. Not used for proportion or event quantile metrics.").optional(), "filters": z.array(z.string()).describe("Array of Fact Table Filter Ids. Deprecated, use rowFilters instead.").optional(), "inlineFilters": z.record(z.string(), z.array(z.string())).describe("Inline filters to apply to the fact table. Keys are column names, values are arrays of values to filter by. Deprecated, use rowFilters instead.").optional(), "rowFilters": z.array(z.object({ "operator": z.enum(["=","!=",">","<",">=","<=","in","not_in","is_null","not_null","is_true","is_false","contains","not_contains","starts_with","ends_with","sql_expr","saved_filter"]), "values": z.array(z.string()).describe("Not required for is_null, not_null, is_true, is_false operators.").optional(), "column": z.string().describe("Required for all operators except sql_expr and saved_filter.").optional() })).describe("Filters to apply to the rows of the fact table before aggregation.").optional(), "aggregateFilterColumn": z.string().describe("Column to use to filter users after aggregation. Either '$$count' of rows or the name of a numeric column that will be summed by user. Must specify `aggregateFilter` if using this. Only can be used with 'retention' and 'proportion' metrics.").optional(), "aggregateFilter": z.string().describe("Simple comparison operator and value to apply after aggregation (e.g. '= 10' or '>= 1'). Requires `aggregateFilterColumn`.").optional() }), "denominator": z.object({ "factTableId": z.string(), "column": z.string().describe("The column name or one of the special values: '$$distinctUsers' or '$$count' (or '$$distinctDates' if metricType is 'mean' or 'ratio' or 'quantile' and quantileSettings.type is 'unit')"), "aggregation": z.enum(["sum","max","count distinct"]).describe("User aggregation of selected column. Either sum or max for numeric columns; count distinct for string columns; ignored for special columns. Default: sum. If you specify a string column you must explicitly specify count distinct. Not used for proportion or event quantile metrics.").optional(), "filters": z.array(z.string()).describe("Array of Fact Table Filter Ids. Deprecated, use rowFilters instead.").optional(), "inlineFilters": z.record(z.string(), z.array(z.string())).describe("Inline filters to apply to the fact table. Keys are column names, values are arrays of values to filter by. Deprecated, use rowFilters instead.").optional(), "rowFilters": z.array(z.object({ "operator": z.enum(["=","!=",">","<",">=","<=","in","not_in","is_null","not_null","is_true","is_false","contains","not_contains","starts_with","ends_with","sql_expr","saved_filter"]), "values": z.array(z.string()).describe("Not required for is_null, not_null, is_true, is_false operators.").optional(), "column": z.string().describe("Required for all operators except sql_expr and saved_filter.").optional() })).describe("Filters to apply to the rows of the fact table before aggregation.").optional() }).describe("Only when metricType is 'ratio'").optional(), "inverse": z.boolean().describe("Set to true for things like Bounce Rate, where you want the metric to decrease").optional(), "quantileSettings": z.object({ "type": z.enum(["event","unit"]).describe("Whether the quantile is over unit aggregations or raw event values"), "ignoreZeros": z.boolean().describe("If true, zero values will be ignored when calculating the quantile"), "quantile": z.number().multipleOf(0.001).gte(0.001).lte(0.999).describe("The quantile value (from 0.001 to 0.999)") }).describe("Controls the settings for quantile metrics (mandatory if metricType is \"quantile\")").optional(), "cappingSettings": z.object({ "type": z.enum(["none","absolute","percentile"]), "value": z.number().describe("When type is absolute, this is the absolute value. When type is percentile, this is the percentile value (from 0.0 to 1.0).").optional(), "ignoreZeros": z.boolean().describe("If true and capping is `percentile`, zeros will be ignored when calculating the percentile.").optional() }).describe("Controls how outliers are handled").optional(), "windowSettings": z.object({ "type": z.enum(["none","conversion","lookback"]), "delayHours": z.number().describe("Wait this many hours after experiment exposure before counting conversions. Ignored if delayValue is set.").optional(), "delayValue": z.number().describe("Wait this long after experiment exposure before counting conversions.").optional(), "delayUnit": z.enum(["minutes","hours","days","weeks"]).describe("Default `hours`.").optional(), "windowValue": z.number().optional(), "windowUnit": z.enum(["minutes","hours","days","weeks"]).describe("Default `hours`.").optional() }).describe("Controls the conversion window for the metric").optional(), "priorSettings": z.object({ "override": z.boolean().describe("If false, the organization default settings will be used instead of the other settings in this object"), "proper": z.boolean().describe("If true, the `mean` and `stddev` will be used, otherwise we will use an improper flat prior."), "mean": z.number().describe("The mean of the prior distribution of relative effects in proportion terms (e.g. 0.01 is 1%)"), "stddev": z.number().gt(0).describe("Must be > 0. The standard deviation of the prior distribution of relative effects in proportion terms.") }).describe("Controls the bayesian prior for the metric. If omitted, organization defaults will be used.").optional(), "regressionAdjustmentSettings": z.object({ "override": z.boolean().describe("If false, the organization default settings will be used"), "enabled": z.boolean().describe("Controls whether or not regression adjustment is applied to the metric").optional(), "days": z.number().describe("Number of pre-exposure days to use for the regression adjustment").optional() }).describe("Controls the regression adjustment (CUPED) settings for the metric").optional(), "riskThresholdSuccess": z.number().gte(0).describe("Threshold for Risk to be considered low enough, as a proportion (e.g. put 0.0025 for 0.25%). <br/> Must be a non-negative number and must not be higher than `riskThresholdDanger`.").optional(), "riskThresholdDanger": z.number().gte(0).describe("Threshold for Risk to be considered too high, as a proportion (e.g. put 0.0125 for 1.25%). <br/> Must be a non-negative number.").optional(), "displayAsPercentage": z.boolean().describe("If true and the metric is a ratio or dailyParticipation metric, variation means will be displayed as a percentage. Defaults to true for dailyParticipation metrics and false for ratio metrics.").optional(), "minPercentChange": z.number().gte(0).describe("Minimum percent change to consider uplift significant, as a proportion (e.g. put 0.005 for 0.5%)").optional(), "maxPercentChange": z.number().gte(0).describe("Maximum percent change to consider uplift significant, as a proportion (e.g. put 0.5 for 50%)").optional(), "minSampleSize": z.number().gte(0).optional(), "targetMDE": z.number().gte(0).describe("The percentage change that you want to reliably detect before ending an experiment, as a proportion (e.g. put 0.1 for 10%). This is used to estimate the \"Days Left\" for running experiments.").optional(), "managedBy": z.enum(["","api","admin"]).describe("Set this to \"api\" to disable editing in the GrowthBook UI").optional(), "metricAutoSlices": z.array(z.string()).describe("Array of slice column names that will be automatically included in metric analysis. This is an enterprise feature.").optional() }).strict(),
  querySchema: z.never(),
  paramsSchema: z.never(),
};

export const getFactMetricValidator = {
  bodySchema: z.never(),
  querySchema: z.never(),
  paramsSchema: z.object({ "id": z.string() }).strict(),
};

export const updateFactMetricValidator = {
  bodySchema: z.object({ "name": z.string().optional(), "description": z.string().optional(), "owner": z.string().optional(), "projects": z.array(z.string()).optional(), "tags": z.array(z.string()).optional(), "metricType": z.enum(["proportion","retention","mean","quantile","ratio","dailyParticipation"]).optional(), "numerator": z.object({ "factTableId": z.string(), "column": z.string().describe("Must be empty for proportion metrics and dailyParticipation metrics. Otherwise, the column name or one of the special values: '$$distinctUsers' or '$$count' (or '$$distinctDates' if metricType is 'mean' or 'ratio' or 'quantile' and quantileSettings.type is 'unit')").optional(), "aggregation": z.enum(["sum","max","count distinct"]).describe("User aggregation of selected column. Either sum or max for numeric columns; count distinct for string columns; ignored for special columns. Default: sum. If you specify a string column you must explicitly specify count distinct. Not used for proportion or event quantile metrics.").optional(), "filters": z.array(z.string()).describe("Array of Fact Table Filter Ids. Deprecated, use rowFilters instead.").optional(), "inlineFilters": z.record(z.string(), z.array(z.string())).describe("Inline filters to apply to the fact table. Keys are column names, values are arrays of values to filter by. Deprecated, use rowFilters instead.").optional(), "rowFilters": z.array(z.object({ "operator": z.enum(["=","!=",">","<",">=","<=","in","not_in","is_null","not_null","is_true","is_false","contains","not_contains","starts_with","ends_with","sql_expr","saved_filter"]), "values": z.array(z.string()).describe("Not required for is_null, not_null, is_true, is_false operators.").optional(), "column": z.string().describe("Required for all operators except sql_expr and saved_filter.").optional() })).describe("Filters to apply to the rows of the fact table before aggregation.").optional(), "aggregateFilterColumn": z.string().describe("Column to use to filter users after aggregation. Either '$$count' of rows or the name of a numeric column that will be summed by user. Must specify `aggregateFilter` if using this. Only can be used with 'retention' and 'proportion' metrics.").optional(), "aggregateFilter": z.string().describe("Simple comparison operator and value to apply after aggregation (e.g. '= 10' or '>= 1'). Requires `aggregateFilterColumn`.").optional() }).optional(), "denominator": z.object({ "factTableId": z.string(), "column": z.string().describe("The column name or one of the special values: '$$distinctUsers' or '$$count' (or '$$distinctDates' if metricType is 'mean' or 'ratio' or 'quantile' and quantileSettings.type is 'unit')"), "aggregation": z.enum(["sum","max","count distinct"]).describe("User aggregation of selected column. Either sum or max for numeric columns; count distinct for string columns; ignored for special columns. Default: sum. If you specify a string column you must explicitly specify count distinct. Not used for proportion or event quantile metrics.").optional(), "filters": z.array(z.string()).describe("Array of Fact Table Filter Ids. Deprecated, use rowFilters instead.").optional(), "inlineFilters": z.record(z.string(), z.array(z.string())).describe("Inline filters to apply to the fact table. Keys are column names, values are arrays of values to filter by. Deprecated, use rowFilters instead.").optional(), "rowFilters": z.array(z.object({ "operator": z.enum(["=","!=",">","<",">=","<=","in","not_in","is_null","not_null","is_true","is_false","contains","not_contains","starts_with","ends_with","sql_expr","saved_filter"]), "values": z.array(z.string()).describe("Not required for is_null, not_null, is_true, is_false operators.").optional(), "column": z.string().describe("Required for all operators except sql_expr and saved_filter.").optional() })).describe("Filters to apply to the rows of the fact table before aggregation.").optional() }).describe("Only when metricType is 'ratio'").optional(), "inverse": z.boolean().describe("Set to true for things like Bounce Rate, where you want the metric to decrease").optional(), "quantileSettings": z.object({ "type": z.enum(["event","unit"]).describe("Whether the quantile is over unit aggregations or raw event values"), "ignoreZeros": z.boolean().describe("If true, zero values will be ignored when calculating the quantile"), "quantile": z.number().multipleOf(0.001).gte(0.001).lte(0.999).describe("The quantile value (from 0.001 to 0.999)") }).describe("Controls the settings for quantile metrics (mandatory if metricType is \"quantile\")").optional(), "cappingSettings": z.object({ "type": z.enum(["none","absolute","percentile"]), "value": z.number().describe("When type is absolute, this is the absolute value. When type is percentile, this is the percentile value (from 0.0 to 1.0).").optional(), "ignoreZeros": z.boolean().describe("If true and capping is `percentile`, zeros will be ignored when calculating the percentile.").optional() }).describe("Controls how outliers are handled").optional(), "windowSettings": z.object({ "type": z.enum(["none","conversion","lookback"]), "delayHours": z.number().describe("Wait this many hours after experiment exposure before counting conversions. Ignored if delayValue is set.").optional(), "delayValue": z.number().describe("Wait this long after experiment exposure before counting conversions.").optional(), "delayUnit": z.enum(["minutes","hours","days","weeks"]).describe("Default `hours`.").optional(), "windowValue": z.number().optional(), "windowUnit": z.enum(["minutes","hours","days","weeks"]).describe("Default `hours`.").optional() }).describe("Controls the conversion window for the metric").optional(), "regressionAdjustmentSettings": z.object({ "override": z.boolean().describe("If false, the organization default settings will be used"), "enabled": z.boolean().describe("Controls whether or not regression adjustment is applied to the metric").optional(), "days": z.number().describe("Number of pre-exposure days to use for the regression adjustment").optional() }).describe("Controls the regression adjustment (CUPED) settings for the metric").optional(), "riskThresholdSuccess": z.number().gte(0).describe("Threshold for Risk to be considered low enough, as a proportion (e.g. put 0.0025 for 0.25%). <br/> Must be a non-negative number and must not be higher than `riskThresholdDanger`.").optional(), "riskThresholdDanger": z.number().gte(0).describe("Threshold for Risk to be considered too high, as a proportion (e.g. put 0.0125 for 1.25%). <br/> Must be a non-negative number.").optional(), "displayAsPercentage": z.boolean().describe("If true and the metric is a ratio or dailyParticipation metric, variation means will be displayed as a percentage. Defaults to true for dailyParticipation metrics and false for ratio metrics.").optional(), "minPercentChange": z.number().gte(0).describe("Minimum percent change to consider uplift significant, as a proportion (e.g. put 0.005 for 0.5%)").optional(), "maxPercentChange": z.number().gte(0).describe("Maximum percent change to consider uplift significant, as a proportion (e.g. put 0.5 for 50%)").optional(), "minSampleSize": z.number().gte(0).optional(), "targetMDE": z.number().gte(0).optional(), "managedBy": z.enum(["","api","admin"]).describe("Set this to \"api\" to disable editing in the GrowthBook UI").optional(), "archived": z.boolean().optional(), "metricAutoSlices": z.array(z.string()).describe("Array of slice column names that will be automatically included in metric analysis. This is an enterprise feature.").optional() }).strict(),
  querySchema: z.never(),
  paramsSchema: z.object({ "id": z.string() }).strict(),
};

export const deleteFactMetricValidator = {
  bodySchema: z.never(),
  querySchema: z.never(),
  paramsSchema: z.object({ "id": z.string() }).strict(),
};

export const postFactMetricAnalysisValidator = {
  bodySchema: z.object({ "userIdType": z.string().describe("The identifier type to use for the analysis. If not provided, defaults to the first available identifier type in the fact table.").optional(), "lookbackDays": z.number().gte(1).lte(999999).describe("Number of days to look back for the analysis. Defaults to 30.").optional(), "populationType": z.enum(["factTable","segment"]).describe("The type of population to analyze. Defaults to 'factTable', meaning the analysis will return the metric value for all units found in the fact table.").optional(), "populationId": z.string().nullable().describe("The ID of the population (e.g., segment ID) when populationType is not 'factTable'. Defaults to null.").optional(), "additionalNumeratorFilters": z.array(z.string()).describe("We support passing in adhoc filters for an analysis that don't live on the metric itself. These are in addition to the metric's filters. To use this, you can pass in an array of Fact Table Filter Ids.").optional(), "additionalDenominatorFilters": z.array(z.string()).describe("We support passing in adhoc filters for an analysis that don't live on the metric itself. These are in addition to the metric's filters. To use this, you can pass in an array of Fact Table Filter Ids.").optional(), "useCache": z.boolean().describe("Whether to use a cached query if one exists. Defaults to true.").optional() }).strict(),
  querySchema: z.never(),
  paramsSchema: z.object({ "id": z.string() }).strict(),
};

export const postBulkImportFactsValidator = {
  bodySchema: z.object({ "factTables": z.array(z.object({ "id": z.string(), "data": z.object({ "name": z.string(), "description": z.string().describe("Description of the fact table").optional(), "owner": z.string().describe("The person who is responsible for this fact table").optional(), "projects": z.array(z.string()).describe("List of associated project ids").optional(), "tags": z.array(z.string()).describe("List of associated tags").optional(), "datasource": z.string().describe("The datasource id"), "userIdTypes": z.array(z.string()).describe("List of identifier columns in this table. For example, \"id\" or \"anonymous_id\""), "sql": z.string().describe("The SQL query for this fact table"), "eventName": z.string().describe("The event name used in SQL template variables").optional(), "managedBy": z.enum(["","api","admin"]).describe("Set this to \"api\" to disable editing in the GrowthBook UI").optional() }) })).optional(), "factTableFilters": z.array(z.object({ "factTableId": z.string(), "id": z.string(), "data": z.object({ "name": z.string(), "description": z.string().describe("Description of the fact table filter").optional(), "value": z.string().describe("The SQL expression for this filter."), "managedBy": z.enum(["","api"]).describe("Set this to \"api\" to disable editing in the GrowthBook UI. Before you do this, the Fact Table itself must also be marked as \"api\"").optional() }) })).optional(), "factMetrics": z.array(z.object({ "id": z.string(), "data": z.object({ "name": z.string(), "description": z.string().optional(), "owner": z.string().optional(), "projects": z.array(z.string()).optional(), "tags": z.array(z.string()).optional(), "metricType": z.enum(["proportion","retention","mean","quantile","ratio","dailyParticipation"]), "numerator": z.object({ "factTableId": z.string(), "column": z.string().describe("Must be empty for proportion metrics and dailyParticipation metrics. Otherwise, the column name or one of the special values: '$$distinctUsers' or '$$count' (or '$$distinctDates' if metricType is 'mean' or 'ratio' or 'quantile' and quantileSettings.type is 'unit')").optional(), "aggregation": z.enum(["sum","max","count distinct"]).describe("User aggregation of selected column. Either sum or max for numeric columns; count distinct for string columns; ignored for special columns. Default: sum. If you specify a string column you must explicitly specify count distinct. Not used for proportion or event quantile metrics.").optional(), "filters": z.array(z.string()).describe("Array of Fact Table Filter Ids. Deprecated, use rowFilters instead.").optional(), "inlineFilters": z.record(z.string(), z.array(z.string())).describe("Inline filters to apply to the fact table. Keys are column names, values are arrays of values to filter by. Deprecated, use rowFilters instead.").optional(), "rowFilters": z.array(z.object({ "operator": z.enum(["=","!=",">","<",">=","<=","in","not_in","is_null","not_null","is_true","is_false","contains","not_contains","starts_with","ends_with","sql_expr","saved_filter"]), "values": z.array(z.string()).describe("Not required for is_null, not_null, is_true, is_false operators.").optional(), "column": z.string().describe("Required for all operators except sql_expr and saved_filter.").optional() })).describe("Filters to apply to the rows of the fact table before aggregation.").optional(), "aggregateFilterColumn": z.string().describe("Column to use to filter users after aggregation. Either '$$count' of rows or the name of a numeric column that will be summed by user. Must specify `aggregateFilter` if using this. Only can be used with 'retention' and 'proportion' metrics.").optional(), "aggregateFilter": z.string().describe("Simple comparison operator and value to apply after aggregation (e.g. '= 10' or '>= 1'). Requires `aggregateFilterColumn`.").optional() }), "denominator": z.object({ "factTableId": z.string(), "column": z.string().describe("The column name or one of the special values: '$$distinctUsers' or '$$count' (or '$$distinctDates' if metricType is 'mean' or 'ratio' or 'quantile' and quantileSettings.type is 'unit')"), "aggregation": z.enum(["sum","max","count distinct"]).describe("User aggregation of selected column. Either sum or max for numeric columns; count distinct for string columns; ignored for special columns. Default: sum. If you specify a string column you must explicitly specify count distinct. Not used for proportion or event quantile metrics.").optional(), "filters": z.array(z.string()).describe("Array of Fact Table Filter Ids. Deprecated, use rowFilters instead.").optional(), "inlineFilters": z.record(z.string(), z.array(z.string())).describe("Inline filters to apply to the fact table. Keys are column names, values are arrays of values to filter by. Deprecated, use rowFilters instead.").optional(), "rowFilters": z.array(z.object({ "operator": z.enum(["=","!=",">","<",">=","<=","in","not_in","is_null","not_null","is_true","is_false","contains","not_contains","starts_with","ends_with","sql_expr","saved_filter"]), "values": z.array(z.string()).describe("Not required for is_null, not_null, is_true, is_false operators.").optional(), "column": z.string().describe("Required for all operators except sql_expr and saved_filter.").optional() })).describe("Filters to apply to the rows of the fact table before aggregation.").optional() }).describe("Only when metricType is 'ratio'").optional(), "inverse": z.boolean().describe("Set to true for things like Bounce Rate, where you want the metric to decrease").optional(), "quantileSettings": z.object({ "type": z.enum(["event","unit"]).describe("Whether the quantile is over unit aggregations or raw event values"), "ignoreZeros": z.boolean().describe("If true, zero values will be ignored when calculating the quantile"), "quantile": z.number().multipleOf(0.001).gte(0.001).lte(0.999).describe("The quantile value (from 0.001 to 0.999)") }).describe("Controls the settings for quantile metrics (mandatory if metricType is \"quantile\")").optional(), "cappingSettings": z.object({ "type": z.enum(["none","absolute","percentile"]), "value": z.number().describe("When type is absolute, this is the absolute value. When type is percentile, this is the percentile value (from 0.0 to 1.0).").optional(), "ignoreZeros": z.boolean().describe("If true and capping is `percentile`, zeros will be ignored when calculating the percentile.").optional() }).describe("Controls how outliers are handled").optional(), "windowSettings": z.object({ "type": z.enum(["none","conversion","lookback"]), "delayHours": z.number().describe("Wait this many hours after experiment exposure before counting conversions. Ignored if delayValue is set.").optional(), "delayValue": z.number().describe("Wait this long after experiment exposure before counting conversions.").optional(), "delayUnit": z.enum(["minutes","hours","days","weeks"]).describe("Default `hours`.").optional(), "windowValue": z.number().optional(), "windowUnit": z.enum(["minutes","hours","days","weeks"]).describe("Default `hours`.").optional() }).describe("Controls the conversion window for the metric").optional(), "priorSettings": z.object({ "override": z.boolean().describe("If false, the organization default settings will be used instead of the other settings in this object"), "proper": z.boolean().describe("If true, the `mean` and `stddev` will be used, otherwise we will use an improper flat prior."), "mean": z.number().describe("The mean of the prior distribution of relative effects in proportion terms (e.g. 0.01 is 1%)"), "stddev": z.number().gt(0).describe("Must be > 0. The standard deviation of the prior distribution of relative effects in proportion terms.") }).describe("Controls the bayesian prior for the metric. If omitted, organization defaults will be used.").optional(), "regressionAdjustmentSettings": z.object({ "override": z.boolean().describe("If false, the organization default settings will be used"), "enabled": z.boolean().describe("Controls whether or not regression adjustment is applied to the metric").optional(), "days": z.number().describe("Number of pre-exposure days to use for the regression adjustment").optional() }).describe("Controls the regression adjustment (CUPED) settings for the metric").optional(), "riskThresholdSuccess": z.number().gte(0).describe("Threshold for Risk to be considered low enough, as a proportion (e.g. put 0.0025 for 0.25%). <br/> Must be a non-negative number and must not be higher than `riskThresholdDanger`.").optional(), "riskThresholdDanger": z.number().gte(0).describe("Threshold for Risk to be considered too high, as a proportion (e.g. put 0.0125 for 1.25%). <br/> Must be a non-negative number.").optional(), "displayAsPercentage": z.boolean().describe("If true and the metric is a ratio or dailyParticipation metric, variation means will be displayed as a percentage. Defaults to true for dailyParticipation metrics and false for ratio metrics.").optional(), "minPercentChange": z.number().gte(0).describe("Minimum percent change to consider uplift significant, as a proportion (e.g. put 0.005 for 0.5%)").optional(), "maxPercentChange": z.number().gte(0).describe("Maximum percent change to consider uplift significant, as a proportion (e.g. put 0.5 for 50%)").optional(), "minSampleSize": z.number().gte(0).optional(), "targetMDE": z.number().gte(0).describe("The percentage change that you want to reliably detect before ending an experiment, as a proportion (e.g. put 0.1 for 10%). This is used to estimate the \"Days Left\" for running experiments.").optional(), "managedBy": z.enum(["","api","admin"]).describe("Set this to \"api\" to disable editing in the GrowthBook UI").optional(), "metricAutoSlices": z.array(z.string()).describe("Array of slice column names that will be automatically included in metric analysis. This is an enterprise feature.").optional() }) })).optional() }).strict(),
  querySchema: z.never(),
  paramsSchema: z.never(),
};

export const listCodeRefsValidator = {
  bodySchema: z.never(),
  querySchema: z.object({ "limit": z.coerce.number().int().default(10), "offset": z.coerce.number().int().default(0) }).strict(),
  paramsSchema: z.never(),
};

export const postCodeRefsValidator = {
  bodySchema: z.object({ "branch": z.string(), "repoName": z.string(), "refs": z.array(z.object({ "filePath": z.string(), "startingLineNumber": z.number().int(), "lines": z.string(), "flagKey": z.string(), "contentHash": z.string() })) }).strict(),
  querySchema: z.object({ "deleteMissing": z.enum(["true","false"]).optional() }).strict(),
  paramsSchema: z.never(),
};

export const getCodeRefsValidator = {
  bodySchema: z.never(),
  querySchema: z.never(),
  paramsSchema: z.object({ "id": z.string() }).strict(),
};

export const getQueryValidator = {
  bodySchema: z.never(),
  querySchema: z.never(),
  paramsSchema: z.object({ "id": z.string() }).strict(),
};

export const getSettingsValidator = {
  bodySchema: z.never(),
  querySchema: z.never(),
  paramsSchema: z.never(),
};

export const getCustomFieldsValidator = {
  bodySchema: z.never(),
  querySchema: z.object({ "projectId": z.string().optional() }).strict(),
  paramsSchema: z.never(),
};